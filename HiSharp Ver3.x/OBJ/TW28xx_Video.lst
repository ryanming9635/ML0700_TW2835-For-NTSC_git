C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TW28XX_VIDEO
OBJECT MODULE PLACED IN .\OBJ\TW28xx_Video.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE TW28xx_Video.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\OBJ\TW28xx_Video.lst) TABS(2) OBJECT(.\OBJ\TW28xx_Video.obj)

line level    source

   1          //  **************************************************************************
   2          //
   3          //       Copyright (c) 1992-2006 Professonal Computer Technology Co., Ltd
   4          //
   5          //      All rights are reserved. Reproduction in whole or in parts is
   6          //  prohibited without the prior written consent of the copyright owner.
   7          //  --------------------------------------------------------------------------
   8          //
   9          //  Module: TW28xx_Video.C
  10          //
  11          //  Purpose: Implementation of TW28xx Video.
  12          //
  13          //  Version: 0.01                                   2006/12/11 08:22¤U¤È
  14          //
  15          //  Compiler: Keil 8051 C Compiler v7.2
  16          //
  17          //  Reference:
  18          //
  19          //
  20          //
  21          //  --------------------------------------------------------------------------
  22          //  Modification:
  23          //
  24          //  R0.01 2006/12/11 08:22¤U¤È Phoenix Chuang
  25          //  Reason:
  26          //    1. Original.
  27          //  Solution:
  28          //  
  29          //  **************************************************************************
  30          //  -----------------------------------
  31          //      Header Files
  32          //  ----------------------------------- 
  33          #include "Types.h"
  34          #include "TW28xx_Video.h"
  35          #include "BusCtrl.h"
  36          #include "CommandShell.h"
  37          #include "Win_Table.h"
  38          #include "Timer.h"//andy 20100209 add
  39          #include "TW2835_Init.h"
  40          #include "Main.h"
  41          
  42          //  ------------------------------------
  43          //      Macro Definitions
  44          //  ------------------------------------ 
  45          #define H_FILTER  0x0000
  46          
  47          //  ------------------------------------
  48          //      Type Definitions
  49          //  ------------------------------------
  50          
  51          
  52          //  ------------------------------------
  53          //      Variables Definitions
  54          //  ------------------------------------
C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 2   

  55          code U16 XWinAttr_RegAddr[] = {0x0111, 0x0119, 0x0121, 0x0129, 
  56                           0x0114, 0x011C, 0x0124, 0x012C };
  57          
  58          code U16 XWinPOP_RegAddr[]  = {0x0110, 0x0118, 0x0120, 0x0128, 
  59                           0x0113, 0x011B, 0x0123, 0x012B };
  60          
  61          code U16 YWinAttr_RegAddr[] = {0x0161, 0x0164, 0x0167, 0x016A};
  62          
  63          
  64          extern BYTE xdata Original_selwintype;//Kane @HS 2007 0724 Ver3.4
  65          
  66          extern BYTE TW2837IDCheck;
  67          
  68          //  ------------------------------------
  69          //      Function Prototypes
  70          //  ------------------------------------
  71          
  72          // ===========================================================================
  73          //                      Parallel function description
  74          // ===========================================================================
  75          //
  76          // Auto Detectation Video Format 
  77          //
  78          U8 PCT_DetectVideoFormat(U8 _ch)
  79          {
  80   1        register U8 tmpSta;
  81   1      //  int _delay;
  82   1        // Waitting Color Lock
  83   1        //Kane Modified>>>>
  84   1      #if 1
  85   1        tmpSta = 0; 
  86   1      
  87   1        if( (TW28_ReadByte(0, SENSORCHANNEL<<4)&0x0F) == 0x0F) 
  88   1          tmpSta = TW28_ReadByte(0, _ch << 4);
  89   1      
  90   1        if(tmpSta == 0)
  91   1          return NONE_SYSTEM;
  92   1      
  93   1        tmpSta &= 0xE0;
  94   1        tmpSta >>= 5;
  95   1        return (tmpSta>3)  ? NTSC: PAL; 
  96   1      #else
              //  DELAY_FOR(150);
                tmpSta = TW28_ReadByte(0, _ch << 4);
                if( 0x0F != (tmpSta & 0x0F))
                  return DEF_SYSTEM;
                tmpSta &= 0xE0;
                tmpSta >>= 5;
                return (tmpSta>3)  ? NTSC: PAL; 
              #endif//if 0
 105   1        //Kane Modified<<<<
 106   1      }
 107          
 108          // ===========================================================================
 109          //
 110          // Setting Video Format 
 111          //
 112          void PCT_SetVideoFormat(U8 _dvc, U8 _ch, U8 _fmat)
 113          {
 114   1        register U8 tmpSta, addr;
 115   1        
 116   1        _dvc = 0;
C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 3   

 117   1        addr = _ch << 4 | 0x01;
 118   1        tmpSta = TW28_ReadByte(0, addr);
 119   1        //Kane modified>>>>
 120   1        //tmpSta &= ~VIDEO_ADDR;
 121   1        tmpSta &= 0x8F;
 122   1        // Kane modified<<<<
 123   1        tmpSta |= _fmat;
 124   1        TW28_WriteByte(0, addr, tmpSta);
 125   1      }
 126          
 127          // ===========================================================================
 128          //
 129          // About X channel Video Mixing Control 
 130          //
 131          
 132          // Video Scale Setting
 133          void PCT_SetChanelScale(U8 _ch, WRITE_REG_DATA *datptr)
 134          {
 135   1        code U8 ScaleRgeAddr[]={0x83,0x84,0x81,0x82,
 136   1                    0x93,0x94,0x91,0x92,
 137   1                    0xA3,0xA4,0xA1,0xA2,
 138   1                    0xB3,0xB4,0xB1,0xB2,
 139   1        };
 140   1        U8  *addrptr;
 141   1        register U16 value;
 142   1      
 143   1        #define HB GETHBYTE(value)
 144   1        #define LB GETLBYTE(value)
 145   1        
 146   1        addrptr = ScaleRgeAddr+_ch*4;
 147   1        value = datptr->addr;
 148   1        if(value != 0xFFFF) value += H_FILTER;
 149   1        TW28_WriteByte(0, *addrptr++, HB);
 150   1        TW28_WriteByte(0, *addrptr++, LB);
 151   1        datptr++;
 152   1        value = datptr->addr;
 153   1        TW28_WriteByte(0, *addrptr++, HB);
 154   1        TW28_WriteByte(0, *addrptr++, LB);
 155   1      }
 156          
 157          // Video scale Check 
 158          void PCT_SetVideoHDelay(U8 _typ, PU8 _winch, PU8 _cattr)
 159          {
 160   1        register U8 hdelay;
 161   1      //Kane @HS 2007 0806 Ver3.4>>>>
 162   1      //  if(Original_selwintype == _typ )//Kane @HS 2007 0724 Ver3.4
 163   1      //    return;
 164   1      ////Kane @HS 2007 0806 Ver3.4<<<<
 165   1        BYTE* ptr_Video_HDelay;
 166   1      
 167   1      if(TW2837IDCheck==TRUE)
 168   1        ptr_Video_HDelay=&Video_HDelay37[0];
 169   1      else
 170   1        ptr_Video_HDelay=&Video_HDelay[0];
 171   1      
 172   1        switch(_typ){
 173   2          case VMIX_TYPE_N11:
 174   2          case VMIX_TYPE_P11:
 175   2          //Kane @HS 2007 0806 Ver3.4>>>> 
 176   2            //if(Original_selwintype == _typ)//Kane @HS 2007 0724 Ver3.4
 177   2            //break;
 178   2          //Kane @HS 2007 0806 Ver3.4<<<<
C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 4   

 179   2            hdelay = 0x08|SYSTYPE;
 180   2            hdelay |= (_cattr[0]&0x01)<<1;
 181   2            if(_winch[0]&0x01)
 182   2              hdelay |= WIN_RIGHT;  // Signal Channel 1,3
 183   2            else
 184   2              hdelay |= WIN_LEFT;   // Signal Channel 0,2
 185   2            if(TW28_ReadByte(0, (_winch[0]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 186   2              TW28_WriteByte(0, (_winch[0]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 187   2            break;
 188   2      
 189   2          case VMIX_TYPE_N21://andy
 190   2          case VMIX_TYPE_P21:
 191   2            // Type N,L,R
 192   2            hdelay = 0x08|WIN_RIGHT|SYSTYPE;  // WIN_RIGHT for Y Channel LEFT
 193   2            hdelay |= (_cattr[0]&0x01)<<1;
 194   2            if(TW28_ReadByte(0, (_winch[0]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 195   2              TW28_WriteByte(0, (_winch[0]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 196   2            // LEFT 
 197   2            hdelay = 0x08|WIN_LEFT|SYSTYPE; // WIN_RIGHT for Y Channel LEFT
 198   2            hdelay |= (_cattr[1]&0x01)<<1;
 199   2            if(TW28_ReadByte(0, (_winch[1]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 200   2              TW28_WriteByte(0, (_winch[1]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 201   2            
 202   2            break;
 203   2      
 204   2          case VMIX_TYPE_N22:
 205   2          case VMIX_TYPE_P22:
 206   2            // LEFT 
 207   2            hdelay = WIN_LEFT|SYSTYPE;
 208   2            hdelay |= (_cattr[0]&0x01)<<1;
 209   2            if(TW28_ReadByte(0,( _winch[0]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 210   2              TW28_WriteByte(0, (_winch[0]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 211   2            // RIGHT
 212   2            hdelay = WIN_RIGHT|SYSTYPE;
 213   2            hdelay |= (_cattr[1]&0x01)<<1;
 214   2            if(TW28_ReadByte(0, (_winch[1]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 215   2              TW28_WriteByte(0, (_winch[1]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 216   2            break;
 217   2            
 218   2          case VMIX_TYPE_N31:
 219   2          case VMIX_TYPE_P31:
 220   2            // Type N,L,R
 221   2            hdelay = 0x08|WIN_RIGHT|SYSTYPE;  // WIN_RIGHT for Y Channel LEFT
 222   2            hdelay |= (_cattr[0]&0x01)<<1;
 223   2            if(TW28_ReadByte(0, (_winch[0]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 224   2              TW28_WriteByte(0, (_winch[0]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 225   2            // LEFT 
 226   2            hdelay = WIN_LEFT|SYSTYPE;
 227   2            hdelay |= (_cattr[1]&0x01)<<1;
 228   2            if(TW28_ReadByte(0, (_winch[1]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 229   2              TW28_WriteByte(0, (_winch[1]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 230   2            // RIGHT
 231   2            hdelay = WIN_RIGHT|SYSTYPE;
 232   2            hdelay |= (_cattr[2]&0x01)<<1;
 233   2            if(TW28_ReadByte(0, (_winch[2]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 234   2              TW28_WriteByte(0, (_winch[2]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 235   2            break;
 236   2      
 237   2          case VMIX_TYPE_N32:
 238   2          case VMIX_TYPE_P32:
 239   2            break;
 240   2      
C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 5   

 241   2          case VMIX_TYPE_N33:
 242   2          case VMIX_TYPE_P33:
 243   2            // Type L,R,R
 244   2            // LEFT 
 245   2            hdelay = WIN_LEFT|SYSTYPE;
 246   2            hdelay |= (_cattr[0]&0x01)<<1;
 247   2            if(TW28_ReadByte(0, (_winch[0]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 248   2              TW28_WriteByte(0, (_winch[0]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 249   2            // RIGHT
 250   2            hdelay = WIN_RIGHT|SYSTYPE;
 251   2            hdelay |= (_cattr[1]&0x01)<<1;
 252   2            if(TW28_ReadByte(0, (_winch[1]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 253   2              TW28_WriteByte(0, (_winch[1]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 254   2            // RIGHT
 255   2            hdelay = WIN_RIGHT|SYSTYPE;
 256   2            hdelay |= (_cattr[2]&0x01)<<1;
 257   2            if(TW28_ReadByte(0,( _winch[2]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 258   2            TW28_WriteByte(0, (_winch[2]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 259   2            break;
 260   2      
 261   2          case VMIX_TYPE_N34:
 262   2          case VMIX_TYPE_P34:
 263   2            // Type L,R,L
 264   2            // LEFT 
 265   2            hdelay = WIN_LEFT|SYSTYPE;
 266   2            hdelay |= (_cattr[0]&0x01)<<1;
 267   2            if(TW28_ReadByte(0, (_winch[0]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 268   2              TW28_WriteByte(0, (_winch[0]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 269   2            // RIGHT
 270   2            hdelay = WIN_RIGHT|SYSTYPE;
 271   2            hdelay |= (_cattr[1]&0x01)<<1;
 272   2            if(TW28_ReadByte(0, (_winch[1]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 273   2              TW28_WriteByte(0, (_winch[1]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 274   2            //Left
 275   2            hdelay = WIN_LEFT|SYSTYPE;
 276   2            hdelay |= (_cattr[2]&0x01)<<1;
 277   2            if(TW28_ReadByte(0, (_winch[2]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 278   2              TW28_WriteByte(0, (_winch[2]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 279   2            break;
 280   2            
 281   2          case VMIX_TYPE_N41:
 282   2          case VMIX_TYPE_P41:
 283   2            // Type L,R,L,R
 284   2            // LEFT 
 285   2            hdelay = WIN_LEFT|SYSTYPE;
 286   2            hdelay |= (_cattr[0]&0x01)<<1;
 287   2            if(TW28_ReadByte(0, (_winch[0]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 288   2              TW28_WriteByte(0, (_winch[0]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 289   2            // RIGHT
 290   2            hdelay = WIN_RIGHT|SYSTYPE;
 291   2            hdelay |= (_cattr[1]&0x01)<<1;
 292   2            if(TW28_ReadByte(0,( _winch[1]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 293   2              TW28_WriteByte(0, (_winch[1]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 294   2            // Left
 295   2            hdelay = WIN_LEFT|SYSTYPE;
 296   2            hdelay |= (_cattr[2]&0x01)<<1;
 297   2            if(TW28_ReadByte(0, (_winch[2]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
 298   2              TW28_WriteByte(0, (_winch[2]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 299   2            // RIGHT
 300   2            hdelay = WIN_RIGHT|SYSTYPE;
 301   2            hdelay |= (_cattr[3]&0x01)<<1;
 302   2            if(TW28_ReadByte(0, (_winch[3]<<4)|0x02) != ptr_Video_HDelay[hdelay])//Kane @HS 2007 0808 Ver3.4
C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 6   

 303   2              TW28_WriteByte(0, (_winch[3]<<4)|0x02,ptr_Video_HDelay[hdelay]);
 304   2            break;
 305   2      
 306   2          default :
 307   2            break;
 308   2        }
 309   1      }
 310          
 311          // X Channel Video Mixing Control
 312          void PCT_SetXVideoMixing(U8 _typ, PU8 _winch)
 313          {
 314   1        WRITE_REG_DATA *wregptr;
 315   1      
 316   1        TW28_WriteByte(1, 0x10, (_winch[0]&0x03)|0x80);
 317   1        TW28_WriteByte(1, 0x18, (_winch[1]&0x03)|0x80);
 318   1        TW28_WriteByte(1, 0x20, (_winch[2]&0x03)|0x80);
 319   1        TW28_WriteByte(1, 0x28, (_winch[3]&0x03)|0x80);
 320   1      
 321   1        switch(_typ){
 322   2          case VMIX_TYPE_N11:
 323   2          case VMIX_TYPE_P11:
 324   2            //if(Original_selwintype == _typ)//Kane @HS 2007 0724 Ver3.4
 325   2            //break;
 326   2      
 327   2            wregptr = Init_Vido_W1+SYSTYPE*19;
 328   2            PCT_SetChanelScale(_winch[0], wregptr);
 329   2            TW28_WriteSTable(0, wregptr+2);
 330   2            break;
 331   2      
 332   2          case VMIX_TYPE_N21:
 333   2          case VMIX_TYPE_N22:
 334   2          case VMIX_TYPE_P21:
 335   2          case VMIX_TYPE_P22:
 336   2            wregptr = Init_Vido_W2+SYSTYPE*TYPE2_OFSET*2;
 337   2            wregptr += ((_typ&0x0F)-1)*TYPE2_OFSET;
 338   2      
 339   2            PCT_SetChanelScale(_winch[0], wregptr);
 340   2            PCT_SetChanelScale(_winch[1], wregptr);
 341   2            TW28_WriteSTable(0, wregptr+2);
 342   2            break;
 343   2      
 344   2          case VMIX_TYPE_N31:
 345   2          case VMIX_TYPE_N32:
 346   2          case VMIX_TYPE_N33:
 347   2          case VMIX_TYPE_N34:
 348   2          case VMIX_TYPE_P31:
 349   2          case VMIX_TYPE_P32:
 350   2          case VMIX_TYPE_P33:
 351   2          case VMIX_TYPE_P34:
 352   2            wregptr = Init_Vido_W3+SYSTYPE*TYPE3_OFSET*4;
 353   2            wregptr += ((_typ&0x0F)-1)*TYPE3_OFSET;
 354   2      
 355   2            PCT_SetChanelScale(_winch[0], wregptr+0);
 356   2            PCT_SetChanelScale(_winch[1], wregptr+2);
 357   2            PCT_SetChanelScale(_winch[2], wregptr+4);
 358   2            TW28_WriteSTable(0, wregptr+6);
 359   2            break;
 360   2      
 361   2          case VMIX_TYPE_N41:
 362   2          case VMIX_TYPE_P41:
 363   2            wregptr = Init_Vido_W4+SYSTYPE*19;
 364   2            PCT_SetChanelScale(_winch[0], wregptr);
C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 7   

 365   2            PCT_SetChanelScale(_winch[1], wregptr);
 366   2            PCT_SetChanelScale(_winch[2], wregptr);
 367   2            PCT_SetChanelScale(_winch[3], wregptr);
 368   2            TW28_WriteSTable(0, wregptr+2);
 369   2            break;
 370   2      
 371   2          default :
 372   2            break;
 373   2        }
 374   1      }
 375          
 376          // ===========================================================================
 377          //
 378          // About Y channel Video Mixing Control 
 379          //
 380          void PCT_SetYVideoMixing(U8 _typ)
 381          {
 382   1        TW28_WriteSTable(0, Init_Vido_Y + _typ * YTYPE_OFSET);
 383   1      }
 384          
 385          // About Y channel Video Hdelay 
 386          void PCT_RecompenseYHdelay (PU8 _chmiro)
 387          {
 388   1        switch(TW28_ReadByte(0x01, 0x6C)){
 389   2        case 0x00:
 390   2          
 391   2          if(TW28_ReadByte(0, 0x02) != Video_HDelay[WIN_LEFT+((_chmiro[0]&BIT0)<<1)+SYSTYPE])//Kane @HS 2007 0808 
             -Ver3.4
 392   2            TW28_WriteByte(0x00, 0x02, Video_HDelay[WIN_LEFT+((_chmiro[0]&BIT0)<<1)+SYSTYPE]);
 393   2          if(TW28_ReadByte(0, 0x12) != Video_HDelay[WIN_RIGHT+((_chmiro[1]&BIT0)<<1)+SYSTYPE])//Kane @HS 2007 0808
             - Ver3.4
 394   2            TW28_WriteByte(0x00, 0x12, Video_HDelay[WIN_RIGHT+((_chmiro[1]&BIT0)<<1)+SYSTYPE]);
 395   2          if(TW28_ReadByte(0, 0x22) != Video_HDelay[WIN_LEFT+((_chmiro[2]&BIT0)<<1)+SYSTYPE])//Kane @HS 2007 0808 
             -Ver3.4
 396   2            TW28_WriteByte(0x00, 0x22, Video_HDelay[WIN_LEFT+((_chmiro[2]&BIT0)<<1)+SYSTYPE]);
 397   2          if(TW28_ReadByte(0, 0x32) != Video_HDelay[WIN_RIGHT+((_chmiro[3]&BIT0)<<1)+SYSTYPE])//Kane @HS 2007 0808
             - Ver3.4
 398   2            TW28_WriteByte(0x00, 0x32, Video_HDelay[WIN_RIGHT+((_chmiro[3]&BIT0)<<1)+SYSTYPE]);
 399   2          break;
 400   2      
 401   2        case 0x03:
 402   2          if(TW28_ReadByte(0, 0x02) != Video_HDelay[0x08+((_chmiro[0]&BIT0)<<1)+SYSTYPE])//William @HS 2007 0829 V
             -er3.4
 403   2            TW28_WriteByte(0x00, 0x02, Video_HDelay[0x08+((_chmiro[0]&BIT0)<<1)+SYSTYPE]);
 404   2          break;
 405   2          
 406   2        case 0x0C:
 407   2          if(TW28_ReadByte(0, 0x12) != Video_HDelay[0x08+((_chmiro[1]&BIT0)<<1)+SYSTYPE])//William @HS 2007 0829 V
             -er3.4
 408   2            TW28_WriteByte(0x00, 0x12, Video_HDelay[0x08+((_chmiro[1]&BIT0)<<1)+SYSTYPE]);
 409   2          break;
 410   2          
 411   2        case 0x30:
 412   2          if(TW28_ReadByte(0, 0x22) != Video_HDelay[0x08+((_chmiro[2]&BIT0)<<1)+SYSTYPE])//William @HS 2007 0829 V
             -er3.4
 413   2          TW28_WriteByte(0x00, 0x22, Video_HDelay[0x08+((_chmiro[2]&BIT0)<<1)+SYSTYPE]);
 414   2          break;
 415   2          
 416   2        case 0xC0:
 417   2          if(TW28_ReadByte(0, 0x32) !=Video_HDelay[0x08+((_chmiro[3]&BIT0)<<1)+SYSTYPE])//William @HS 2007 0829 Ve
             -r3.4
 418   2          TW28_WriteByte(0x00, 0x32, Video_HDelay[0x08+((_chmiro[3]&BIT0)<<1)+SYSTYPE]);
C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 8   

 419   2          break;
 420   2        }
 421   1      }
 422          
 423          // ===========================================================================
 424          //
 425          //  TW2835 Video Mixing last Modify for AC & RB
 426          //
 427          //Kane @HS 2007 0808 Ver3.4>>>>
 428          #if 0  //Pinchi 20150324 disable for compiler warning
              void PCT_VideoLastModify(void)
              {
                register data U8 state=0;
                
                state += (SYSWINLK[0]&0x03);
                state += (SYSWINLK[1]&0x03)<<4;
                state += (SYSWINATTR[0]&BIT0)<<2;
                state += (SYSWINATTR[1]&BIT0)<<6;
              
                switch(state) {
                  case 0x20:
                  case 0x24:
                    TW28_WriteSTable(0, VidoW2_ModifyACNM);
                    break;
              
                  case 0x60:
                  case 0x64:
                    //PCT_CheckSystem();      
                    if((SYSTYPE&BIT0) ==NTSC)//Kane @HS 2007 0813 Cer3.4
                      TW28_WriteSTable(0, VidoW2_ModifyACHM);
                    else
                      TW28_WriteSTable(0, VidoW2_ModifyACHM_PAL);
                    break;
              
                  case 0x13:
                  case 0x53:
                    PCT_WinPOPupCtrl(1);
                    TW28_WriteSTable(0, VidoW2_ModifyRBNM);
                    break;
                  case 0x17:
                  case 0x57:
                    PCT_WinPOPupCtrl(1);
                    TW28_WriteSTable(0, VidoW2_ModifyRBHM);
                    break;
                }
              }
              #endif
 466          
 467          //Kane @HS 2007 0808 Ver3.4<<<<
 468          // ===========================================================================
 469          //
 470          //  TW2835 Attribute Set about Freeze for X Channel                              
 471          //
 472          void PCT_WinAttrCtrl(U8 _wid, U8 _attrsel, U8 _setval)
 473          {
 474   1        #define PAGE GETHBYTE(XWinAttr_RegAddr[_wid])
 475   1        #define ADDR GETLBYTE(XWinAttr_RegAddr[_wid])
 476   1      
 477   1        register U8 dat;
 478   1      
 479   1        dat = TW28_ReadByte(PAGE, ADDR);
 480   1        _setval ? dat |= _attrsel : (dat &= ~_attrsel);
C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 9   

 481   1        TW28_WriteByte(PAGE, ADDR, dat);
 482   1      }
 483          
 484          // ===========================================================================
 485          //
 486          //  TW2835 Attribute Set about Freeze for X Channel                              
 487          //
 488          //extern void PutsP(BYTE * ptr);
 489          //extern void RS_tx(BYTE tx_buf);
 490          void PCT_WinAttrCtrlY(U8 _wid, U8 _attrsel, U8 _setval)
 491          {
 492   1        #define YPAGE GETHBYTE(YWinAttr_RegAddr[_wid])
 493   1        #define YADDR GETLBYTE(YWinAttr_RegAddr[_wid])
 494   1        register U8 dat;
 495   1        
 496   1        dat = TW28_ReadByte(YPAGE, YADDR);
 497   1        _setval ? dat |= _attrsel : (dat &= ~_attrsel);
 498   1        TW28_WriteByte(YPAGE, YADDR, dat);
 499   1      
 500   1      
 501   1      }
 502          
 503          // ===========================================================================
 504          //
 505          //  TW2835 Attribute Set about Freeze                              
 506          //
 507          void PCT_WinAttrClear(U8 _attrsel)
 508          {
 509   1        #define PAGE GETHBYTE(XWinAttr_RegAddr[_wid])
 510   1        #define ADDR GETLBYTE(XWinAttr_RegAddr[_wid])
 511   1      
 512   1        register  U8 _wid;
 513   1        register  U8 dat;
 514   1      
 515   1        for(_wid=0; _wid<8; _wid++) {
 516   2          dat = TW28_ReadByte(PAGE, ADDR);
 517   2          dat &= ~_attrsel;
 518   2          TW28_WriteByte(PAGE, ADDR, dat);
 519   2        }
 520   1      }
 521          
 522          // ===========================================================================
 523          //
 524          // TW2835 Window POP UP 
 525          //
 526          #if 0  //Pinchi 20150324 disable for compiler warning
              void PCT_WinPOPupCtrl(U8 _wid)
              {
                #define POPPAGE GETHBYTE(XWinPOP_RegAddr[_wid])
                #define POPADDR GETLBYTE(XWinPOP_RegAddr[_wid])
              
                register  U8 dat;
              
                dat = TW28_ReadByte(POPPAGE, POPADDR);
                dat |= BIT6;
                TW28_WriteByte(POPPAGE, POPADDR, dat);
              }
              #endif
 539          
 540          // ===========================================================================
 541          // END of File 
 542          // ===========================================================================
C51 COMPILER V9.60.0.0   TW28XX_VIDEO                                                      07/01/2021 14:04:21 PAGE 10  

 543          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2512    ----
   CONSTANT SIZE    =   1123    ----
   XDATA SIZE       =   ----      42
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
