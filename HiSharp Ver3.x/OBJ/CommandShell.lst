C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE COMMANDSHELL
OBJECT MODULE PLACED IN .\OBJ\CommandShell.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE CommandShell.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\OBJ\CommandShell.lst) TABS(2) OBJECT(.\OBJ\CommandShell.obj)

line level    source

   1          //  **************************************************************************
   2          //
   3          //       Copyright (c) 1992-2006 Professonal Computer Technology Co., Ltd
   4          //
   5          //      All rights are reserved. Reproduction in whole or in parts is
   6          //  prohibited without the prior written consent of the copyright owner.
   7          //  --------------------------------------------------------------------------
   8          //
   9          //  Module: CommandSell.C
  10          //
  11          //  Purpose: Implementation of CommandSell.
  12          //
  13          //  Version: 0.01                                   2006/10/22 10:39¤U¤È
  14          //
  15          //  Compiler: Keil 8051 C Compiler v7.2
  16          //
  17          //  Reference:
  18          //
  19          //
  20          //
  21          //  --------------------------------------------------------------------------
  22          //  Modification:
  23          //
  24          //  R0.01 2006/10/22 10:39¤U¤È Phoenix Chuang
  25          //  Reason:
  26          //    1. Original.
  27          //  Solution:
  28          //  
  29          //  **************************************************************************
  30          //  -----------------------------------
  31          //      Header Files
  32          //  ----------------------------------- 
  33          #include "Types.h"
  34          #include "CommandShell.h"
  35          #include "UART.h"
  36          #include "Timer.h"
  37          #include "BusCtrl.h"
  38          #include "TW2835_Init.h"
  39          #include "TW28xx_Audio.h"
  40          #include "TW28xx_Video.h"
  41          #include "OSDCtrl.h"
  42          #include "OSDAction.h"
  43          #include "Main.h"
  44          
  45          #include "Printf.h"
  46          #include "monitor.h"
  47          
  48          // Table define on code
  49          
  50          
  51          //  ------------------------------------
  52          //      Macro Definitions
  53          //  ------------------------------------ 
  54          #define WINCH     sysdat.channel_link
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 2   

  55          #define RECWINTYPE  sysdat.video_mix_type
  56          #define RECLKTP     sysdat.link_type
  57          #define OSDREFALSH  msg.osd_falsh
  58          #define selwintype  msg.video_mix_type
  59            
  60          //  ------------------------------------
  61          //      Type Definitions
  62          //  ------------------------------------
  63          #if (TW2835_MCU == TW8806_MODEL_WINBOND)  //Pinchi 20150401 add
              #define VERSION "320"
              #else
  66            #if (defined UTC)
                #define VERSION "333"
                #elif (defined HS)
                  #ifdef HOLGER
                  #define VERSION "335" ///for Holger PAL
                  #else
                  #define VERSION "334"
                  #endif
                #else
  75            #define VERSION "332"
  76            #endif
  77          #endif
  78          
  79          #ifdef HOLGER
              #define VIDEO_SYS   'P' //NTSC
              #else
  82          #define VIDEO_SYS   'N' //NTSC
  83          #endif
  84          
  85          //  ------------------------------------
  86          //      Variables Definitions
  87          //  ------------------------------------
  88            SYS_DATA sysdat;
  89            SYS_MESSAGE msg;
  90          #if (TW2837_DEBUG==ON)
                extern U8 access;
              #endif
  93          //  extern bit VlossFlag;//ryan@20150318
  94          
  95          //  ------------------------------------
  96          //      Function Prototypes
  97          //  ------------------------------------
  98          
  99          // ***************************************************************************
 100          
 101          // ===========================================================================
 102          //                      Parallel function description
 103          // ===========================================================================
 104          //
 105          // Get Command String from Command Buffer
 106          //
 107          U8 PCT_GetFirstStr(char **tagStr, char **sourceStr) 
 108          {
 109   1        if( **sourceStr == '\0' ) return false;
 110   1        while(**sourceStr == ' ' ) (*sourceStr)++;
 111   1        *tagStr = *sourceStr;
 112   1        (*sourceStr)++;
 113   1        while(1) {
 114   2          if( **sourceStr==' ' ) {
 115   3            **sourceStr = '\0';
 116   3            (*sourceStr)++;
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 3   

 117   3            return true;
 118   3          } else if( **sourceStr == '\0' ) {
 119   3            return true;
 120   3          } else (*sourceStr)++;
 121   2        }
 122   1      }
 123          
 124          // ===========================================================================
 125          //
 126          // String Transfer to Command Code 
 127          //
 128          U16 PCT_StrToCommCode(char *Str)
 129          {
 130   1        data U16 ret=0;
 131   1        
 132   1        while(*Str != '\0' ) ret+=*Str++;
 133   1        return ret;
 134   1      }
 135          
 136          // ===========================================================================
 137          //
 138          // Send ACK to TW8806
 139          //
 140          void PCT_SendACK(void)
 141          {
 142   1        RS_tx('A');
 143   1        RS_tx('C');
 144   1        RS_tx('K');
 145   1      }
 146          
 147          // ===========================================================================
 148          //
 149          // ===========================================================================
 150          //
 151          void PCT_CheckVMixType(U8 _typ)
 152          {
 153   1        data U8 tmplktp=0;
 154   1        
 155   1        tmplktp += (WINCH[0]&0x03); 
 156   1        tmplktp += (WINCH[1]&0x03)<<2; 
 157   1        tmplktp += (WINCH[2]&0x03)<<4; 
 158   1        tmplktp += (WINCH[3]&0x03)<<6; 
 159   1        
 160   1        if((RECWINTYPE==_typ)&&(tmplktp==RECLKTP)) {
 161   2          OSDREFALSH = OFF;
 162   2          return; 
 163   2        }
 164   1        OSDREFALSH = ON;
 165   1        RECLKTP = tmplktp;
 166   1        RECWINTYPE = _typ;
 167   1      }
 168          
 169          // ===========================================================================
 170          
 171          // ***************************************************************************
 172          // Process Command Shell Function
 173          // ***************************************************************************
 174          //
 175          // This is to communicate with PC AP 
 176          //
 177          void MoniReadPageBuffer(PCHAR szParam)
 178          {
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 4   

 179   1        data U8 page, start, end;
 180   1      
 181   1        sscanf(szParam, "%bx %bx %bx", &page, &start, &end); 
 182   1      
 183   1        do {
 184   2          printf("\n<R>%02bx[%02bx]=%02bx", page, start, TW28_ReadByte(page, start) );
 185   2          start++;
 186   2        }while(start != end);
 187   1      }
 188          
 189          // ***************************************************************************
 190          //
 191          // This is to communicate with PC AP 
 192          //
 193          void MoniReadOneBuffer(PCHAR szParam)
 194          {
 195   1        data U8 page, addr;
 196   1      
 197   1        sscanf(szParam, "%bx %bx", &page, &addr); 
 198   1      
 199   1        printf("\n<R>%02bx[%02bx]=%02bx", page, addr, TW28_ReadByte(page, addr) );
 200   1      }
 201          
 202          // ***************************************************************************
 203          //
 204          // This is to communicate with PC AP 
 205          //
 206          void MoniWriteOneBuffer(PCHAR szParam)
 207          {
 208   1        data U8 page, addr, dat;
 209   1      
 210   1        sscanf(szParam, "%bx %bx %bx", &page, &addr, &dat); 
 211   1        TW28_WriteByte(page, addr, dat);
 212   1      }
 213          
 214          // ***************************************************************************
 215          //
 216          // Monitor ASCIBUS Write Byte
 217          //
 218          void MoniWriteAsicByte(PCHAR szParam)
 219          {
 220   1        data U8 _dev=0;
 221   1        data U8 _pg=0;
 222   1        data U8 _addr=0;
 223   1        data U8 _wdat=0;
 224   1        
 225   1        sscanf(szParam, "%bx %bx %bx %bx ", &_dev, &_pg, &_addr, &_wdat);
 226   1        TW28_WriteByte(_pg, _addr, _wdat);
 227   1      }
 228          
 229          // ***************************************************************************
 230          //
 231          // Monitor ASCIBUS Write Byte
 232          //
 233          void MoniReadAsicByte(PCHAR szParam)
 234          {
 235   1        data U8 _dev=0;
 236   1        data U8 _pg=0;
 237   1        data U8 _addr=0;
 238   1        data U8 _rdat=0;
 239   1        
 240   1        sscanf(szParam, "%1bx %1bx %1bx ", &_dev, &_pg, &_addr);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 5   

 241   1        _rdat = TW28_ReadByte(_pg, _addr);
 242   1        printf("ReadAsicByte == %bx \n", _rdat);
 243   1      }
 244          
 245          // ***************************************************************************
 246          //
 247          // Monitor Audio Mixing 
 248          // Format : amix N ch0:val ch1:val ch2:val ch3:val ch4:val 
 249          //
 250          void MoniAudioMixing(PCHAR szParam)
 251          {
 252   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 253   1        data U8 valch0,valch1,valch2,valch3,valch4; 
 254   1        char *getStr;
 255   1        code U8 chaddr[] = {ADO_MIX_MUTE_AIN0, \
 256   1                  ADO_MIX_MUTE_AIN1, \
 257   1                  ADO_MIX_MUTE_AIN2, \
 258   1                  ADO_MIX_MUTE_AIN3, \
 259   1                  ADO_MIX_MUTE_PBAI \
 260   1        };  
 261   1      
 262   1        PCT_GetFirstStr(&getStr,&szParam);
 263   1      
 264   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 265   1                  ADO_MIX_MUTE_AIN1+ \
 266   1                  ADO_MIX_MUTE_AIN2+ \
 267   1                  ADO_MIX_MUTE_AIN3+ \
 268   1                  ADO_MIX_MUTE_PBAI, OFF);
 269   1      
 270   1        switch( atoi(getStr) ) {
 271   2        case 1:
 272   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 273   2          PCT_AudioMixCtrl(0, selch0, valch0);
 274   2          PCT_AudioMixMute(0, chaddr[selch0], ON);
 275   2          break;
 276   2        
 277   2        case 2:
 278   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 279   2            &selch0, &valch0, &selch1, &valch1);
 280   2          PCT_AudioMixCtrl(0, selch0, valch0);
 281   2          PCT_AudioMixCtrl(0, selch1, valch1);
 282   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1], ON);
 283   2          break;
 284   2        
 285   2        case 3:
 286   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 287   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 288   2          PCT_AudioMixCtrl(0, selch0, valch0);
 289   2          PCT_AudioMixCtrl(0, selch1, valch1);
 290   2          PCT_AudioMixCtrl(0, selch2, valch2);
 291   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2], ON);
 292   2          break;
 293   2        
 294   2        case 4:
 295   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 296   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 297   2          PCT_AudioMixCtrl(0, selch0, valch0);
 298   2          PCT_AudioMixCtrl(0, selch1, valch1);
 299   2          PCT_AudioMixCtrl(0, selch2, valch2);
 300   2          PCT_AudioMixCtrl(0, selch3, valch3);
 301   2      
 302   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3], ON);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 6   

 303   2          break;
 304   2      
 305   2        case 5:
 306   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 307   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3,  &selch4, &valch4 );
 308   2          PCT_AudioMixCtrl(0, selch0, valch0);
 309   2          PCT_AudioMixCtrl(0, selch1, valch1);
 310   2          PCT_AudioMixCtrl(0, selch2, valch2);
 311   2          PCT_AudioMixCtrl(0, selch3, valch3);
 312   2          PCT_AudioMixCtrl(0, selch4, valch4);
 313   2      
 314   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3]+chaddr[selch4], ON);
 315   2          break;
 316   2        
 317   2        default:
 318   2          break;
 319   2        }
 320   1      }
 321          
 322          // ***************************************************************************
 323          //
 324          // Monitor Audio Mute 
 325          // Format : amute
 326          //
 327          void MoniAudioMute(void)
 328          {
 329   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 330   1                  ADO_MIX_MUTE_AIN1+ \
 331   1                  ADO_MIX_MUTE_AIN2+ \
 332   1                  ADO_MIX_MUTE_AIN3+ \
 333   1                  ADO_MIX_MUTE_PBAI, OFF);
 334   1        PCT_AudioSelLive(0, 0xFF);
 335   1      }
 336          
 337          // ***************************************************************************
 338          //
 339          // Monitor Audio Mixing 
 340          // Format : again N ch0:val ch1:val ch2:val ch3:val ch5:val
 341          //
 342          void MoniAudioGain(PCHAR szParam)
 343          {
 344   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 345   1        data U8 ch0val,ch1val,ch2val,ch3val,ch4val; 
 346   1        char *getStr;
 347   1      
 348   1        PCT_GetFirstStr(&getStr,&szParam);
 349   1      
 350   1        switch( atoi(getStr) ) {
 351   2        case 1:
 352   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&ch0val);
 353   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 354   2          break;
 355   2        
 356   2        case 2:
 357   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 358   2            &selch0, &ch0val, &selch1, &ch1val);
 359   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 360   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 361   2          break;
 362   2        
 363   2        case 3:
 364   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 7   

 365   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val);
 366   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 367   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 368   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 369   2          break;
 370   2        
 371   2        case 4:
 372   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 373   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val);
 374   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 375   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 376   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 377   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 378   2          break;
 379   2        
 380   2        case 5:
 381   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 382   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val, &selch4, &ch4val);
 383   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 384   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 385   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 386   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 387   2          PCT_AudioGainCtrl(0, selch4, ch4val);
 388   2          break;
 389   2        
 390   2        default:
 391   2          break;
 392   2        }
 393   1      }
 394          
 395          // ***************************************************************************
 396          //
 397          // Monitor Select Live or Mixing Mode 
 398          // alive chan (chan=0xFF is Mixing Mode)
 399          //
 400          void MoniAudioLive(PCHAR szParam)
 401          {
 402   1        data U8 chan;
 403   1      
 404   1        sscanf(szParam, "%bd ", &chan);
 405   1      
 406   1        PCT_AudioSelLive(0,chan);
 407   1      }
 408          
 409          // ***************************************************************************
 410          //
 411          // TW2835 Register All Dump
 412          //
 413          void MoniRegisterDump(void)
 414          {
 415   1        data U8 addr,page;
 416   1        
 417   1      
 418   1        for(page=0;page<3;page++) {
 419   2          printf("\n ======== PAGE %b2x =============\n",page);
 420   2          addr = 0;
 421   2          do {
 422   3            printf("%b2x\t", TW28_ReadByte(page, addr));
 423   3            addr++;
 424   3            if((addr%16)==0)  printf("\n"); 
 425   3          } while( addr );
 426   2        }
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 8   

 427   1      }
 428          
 429          // ***************************************************************************
 430          //
 431          // video signal mixing to windows
 432          //
 433          void MoniVideoMixWin(PCHAR szParam)
 434          {
 435   1        data U8 chose,wintp;
 436   1      
 437   1        sscanf(szParam, "%1bx %1bx ch%1bx ch%1bx ch%1bx ch%1bx ",
 438   1                &chose, &wintp, &WINCH[0], &WINCH[1], &WINCH[2], &WINCH[3]);
 439   1        chose = (chose<<4)+(wintp&0x0F);
 440   1        PCT_SetXVideoMixing(chose, WINCH);  
 441   1      }
 442          
 443          // ***************************************************************************
 444          //
 445          // setting windows attribute
 446          //
 447          void MoniVideoMixAttr(PCHAR szParam)
 448          {
 449   1        data U16 chose;
 450   1        data U8 attrsel,setval;
 451   1        data U8   winNm[4],wincnt=0;
 452   1        data U8   division;
 453   1        char *getStr;
 454   1      
 455   1        PCT_GetFirstStr(&getStr,&szParam);
 456   1        division = atoi(getStr); 
 457   1      
 458   1        PCT_GetFirstStr(&getStr,&szParam);
 459   1        chose = PCT_StrToCommCode(getStr); 
 460   1      
 461   1        if( chose==PCT_StrToCommCode("enrecall") ) {
 462   2          attrsel = WIN_RECALL_EN;
 463   2          setval  = ON;
 464   2        } else if ( chose==PCT_StrToCommCode("enfreeze") ) {
 465   2          attrsel = WIN_FREEZE;
 466   2          setval  = ON;
 467   2        } else if ( chose==PCT_StrToCommCode("enhmirror") ) {
 468   2          attrsel = WIN_HMIRROR;
 469   2          setval  = ON;
 470   2        } else if ( chose==PCT_StrToCommCode("envmirror") ) {
 471   2          attrsel = WIN_VMIRROR;
 472   2          setval  = ON;
 473   2        } else if ( chose==PCT_StrToCommCode("enenhance") ) {
 474   2          attrsel = WIN_ENHANCE;
 475   2          setval  = ON;
 476   2        } else if ( chose==PCT_StrToCommCode("enblank") ) {
 477   2          attrsel = WIN_BLANK;
 478   2          setval  = ON;
 479   2        } else if ( chose==PCT_StrToCommCode("enbound") ) {
 480   2          attrsel = WIN_BOUND;
 481   2          setval  = ON;
 482   2        } else if ( chose==PCT_StrToCommCode("enblink") ) {
 483   2          attrsel = WIN_BLINK;
 484   2          setval  = ON;
 485   2        } else if ( chose==PCT_StrToCommCode("disrecall") ) {
 486   2          attrsel = WIN_RECALL_EN;
 487   2          setval  = OFF;
 488   2        } else if ( chose==PCT_StrToCommCode("disfreeze") ) {
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 9   

 489   2          attrsel = WIN_FREEZE;
 490   2          setval  = OFF;
 491   2        } else if ( chose==PCT_StrToCommCode("dishmirror") ) {
 492   2          attrsel = WIN_HMIRROR;
 493   2          setval  = OFF;
 494   2        } else if ( chose==PCT_StrToCommCode("disvmirror") ) {
 495   2          attrsel = WIN_VMIRROR;
 496   2          setval  = OFF;
 497   2        } else if ( chose==PCT_StrToCommCode("disenhance") ) {
 498   2          attrsel = WIN_ENHANCE;
 499   2          setval  = OFF;
 500   2        } else if ( chose==PCT_StrToCommCode("disblank") ) {
 501   2          attrsel = WIN_BLANK;
 502   2          setval  = OFF;
 503   2        } else if ( chose==PCT_StrToCommCode("disbound") ) {
 504   2          attrsel = WIN_BOUND;
 505   2          setval  = OFF;
 506   2        } else if ( chose==PCT_StrToCommCode("disblink") ) {
 507   2          attrsel = WIN_BLINK;
 508   2          setval  = OFF;
 509   2        } else {
 510   2          return;
 511   2        }
 512   1      
 513   1        while( PCT_GetFirstStr(&getStr,&szParam) ) {
 514   2          if(*getStr=='w' && *(getStr+1)=='i' && *(getStr+2)=='n') 
 515   2          {
 516   3            winNm[wincnt] = atoi(getStr+3);
 517   3            wincnt++;
 518   3          }
 519   2        }
 520   1        for( ; wincnt!=0; wincnt--) {
 521   2          if( winNm[wincnt-1]<division ) {
 522   3            PCT_WinAttrCtrl(winNm[wincnt-1], attrsel, setval);
 523   3          }
 524   2        }
 525   1      }
 526          
 527          // ***************************************************************************
 528          //
 529          // Monitor Video Y Channel Select Live or Mixing Mode 
 530          // yvmix chan (chan=0x04 is Mixing Mode)
 531          //
 532          void MoniYVideoMix(PCHAR szParam)
 533          {
 534   1        data U8 chan;
 535   1      
 536   1        sscanf(szParam, "%bd ", &chan);
 537   1        PCT_SetYVideoMixing(chan);
 538   1      }
 539          
 540          // ***************************************************************************
 541          //
 542          // Monitor Video Auto Detect Format 
 543          //
 544          void MoniVideoAutoDetect(void)
 545          {
 546   1        printf("===== Format : ch0=[%bx] ch1=[%bx] ch2=[%bx] ch3=[%bx] =====\n",  \ 
 547   1            PCT_DetectVideoFormat(0x00), \
 548   1            PCT_DetectVideoFormat(0x01), \
 549   1            PCT_DetectVideoFormat(0x02), \
 550   1            PCT_DetectVideoFormat(0x03) \
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 10  

 551   1        );
 552   1      }
 553          
 554          // ***************************************************************************
 555          //
 556          // Monitor Setting Video Format 
 557          //
 558          void MoniSetVideoFormat(PCHAR szParam)
 559          {
 560   1        data U8 selch0,selch1,selch2,selch3;  
 561   1        data U8 valch0,valch1,valch2,valch3;  
 562   1        char *getStr;
 563   1      
 564   1        PCT_GetFirstStr(&getStr,&szParam);
 565   1      
 566   1        switch( atoi(getStr) ) {
 567   2        case 1:
 568   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 569   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 570   2          break;
 571   2        
 572   2        case 2:
 573   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 574   2            &selch0, &valch0, &selch1, &valch1);
 575   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 576   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 577   2          break;
 578   2        
 579   2        case 3:
 580   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 581   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 582   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 583   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 584   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 585   2          break;
 586   2        
 587   2        case 4:
 588   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 589   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 590   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 591   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 592   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 593   2          PCT_SetVideoFormat(0, selch3, valch3<<4);
 594   2          break;
 595   2      
 596   2        default:
 597   2          break;
 598   2        }
 599   1      }
 600          
 601          // ***************************************************************************
 602          //
 603          // Monitor Setting Video Format 
 604          //
 605          void MoniShowSODStr(PCHAR szParam)
 606          {
 607   1        data U8 addrx,addry;
 608   1        char *getStr;
 609   1        
 610   1        PCT_GetFirstStr(&getStr,&szParam);
 611   1        addrx=atoi(getStr);
 612   1        PCT_GetFirstStr(&getStr,&szParam);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 11  

 613   1        addry=atoi(getStr);
 614   1      
 615   1        PCT_PreSetForegroundColor(OSD_COL_100WHT);
 616   1        PCT_PreSetBackgroundColor(OSD_COL_BLU);
 617   1        PCT_SetOSDDrawPage(WRPHX_PAGE5);
 618   1        PCT_ShowOSDString(PTH_X, addrx, addry, szParam);
 619   1        PCT_EnShowOSDPage(WRPHX_PAGE5);
 620   1      }
 621          
 622          // ***************************************************************************
 623          //
 624          // Audio Control for HiSarp
 625          //
 626          void PCT_AudioActionForHS(void)
 627          {
 628   1        data U8 winid;
 629   1        data U8 muteFlage=true;
 630   1      
 631   1        // ------------- Control Audio ------------
 632   1        for(winid=0; winid<4; winid++) {
 633   2          if(SYSWINATTR[winid]&BIT4) {
 634   3            PCT_AudioSelLive(0,WINCH[winid]);
 635   3            muteFlage = false;
 636   3          }
 637   2        }
 638   1      
 639   1        if(muteFlage) {
 640   2          // Audio Mute
 641   2          PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 642   2                    ADO_MIX_MUTE_AIN1+ \
 643   2                    ADO_MIX_MUTE_AIN2+ \
 644   2                    ADO_MIX_MUTE_AIN3+ \
 645   2                    ADO_MIX_MUTE_PBAI, OFF);
 646   2          PCT_AudioSelLive(0, 0xFF);
 647   2        }
 648   1        // ----------------------------------------
 649   1      }
 650          
 651          // ***************************************************************************
 652          //
 653          // Command Shell for HiSarp
 654          //
 655          BYTE xdata Original_selwintype = 0;//Kane @HS 2007 0724 Ver3.4
 656          void MoniHSComm(PCHAR szParam) {
 657   1        data U8 winid;
 658   1        data U8 chose,wintp;
 659   1        
 660   1        sscanf(szParam, "%bx %bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ",
 661   1                &chose, &wintp, &WINCH[0], &SYSWINATTR[0], &WINCH[1], &SYSWINATTR[1], &WINCH[2], &SYSWINATTR[2], &WIN
             -CH[3], &SYSWINATTR[3]);
 662   1      
 663   1        selwintype = (SYSTYPE<<7)+(chose<<4)+(wintp&0x0F);
 664   1      
 665   1        // ----------- Y Chanle setting windows horizontal mirror ----------
 666   1          
 667   1        SYSCHATTR[WINCH[0]]=SYSWINATTR[0];
 668   1        SYSCHATTR[WINCH[1]]=SYSWINATTR[1];
 669   1        SYSCHATTR[WINCH[2]]=SYSWINATTR[2];
 670   1        SYSCHATTR[WINCH[3]]=SYSWINATTR[3];
 671   1      
 672   1        PCT_WinAttrCtrlY(0, WIN_HMIRROR, SYSCHATTR[0]&BIT0);  
 673   1        PCT_WinAttrCtrlY(1, WIN_HMIRROR, SYSCHATTR[1]&BIT0);  
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 12  

 674   1        PCT_WinAttrCtrlY(2, WIN_HMIRROR, SYSCHATTR[2]&BIT0);  
 675   1        PCT_WinAttrCtrlY(3, WIN_HMIRROR, SYSCHATTR[3]&BIT0);  
 676   1        // -----------------------------------------------------------------
 677   1      
 678   1        // ------------- Control Video ------------
 679   1        //if(Original_selwintype != selwintype)//Kane @HS 2007 0724 Ver3.4
 680   1        PCT_RecompenseYHdelay(SYSCHATTR);
 681   1        PCT_SetVideoHDelay(selwintype, WINCH, SYSWINATTR);
 682   1        
 683   1        PCT_SetXVideoMixing(selwintype, WINCH);
 684   1        //PCT_VideoLastModify();
 685   1        for(winid=0; winid<4; winid++) 
 686   1          PCT_WinAttrCtrl(winid, WIN_HMIRROR, SYSWINATTR[winid]&BIT0);
 687   1        // ----------------------------------------
 688   1      
 689   1        // ------------- Control OSD ------------
 690   1        DisUserTimer(USERTMID0);    // Disable real-time detect VLoss
 691   1        EnUserTimer(USERTMID1,5);   // Enable OSD Delay Timer
 692   1        PCT_FlashOSDCtrl(ON);
 693   1        PCT_CheckVMixType(selwintype);
 694   1        PCT_DisShowOSDPage(DISOSD_PHX);
 695   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 696   1        PCT_ShowModeIcon();
 697   1        PCT_OSD_ActionPthX(SYSWINATTR);
 698   1        Original_selwintype = selwintype;//Kane @HS 2007 0724 Ver3.4
 699   1        // --------------------------------------
 700   1      }
 701          
 702          // ***************************************************************************
 703          //
 704          // Real Time Check System Type PAL or NTSC
 705          //
 706          bit PCT_CheckSystem(void)
 707          {
 708   1        //Kane add>>>>
 709   1        char TempSystem;
 710   1        TempSystem = PCT_DetectVideoFormat(SENSORCHANNEL);
 711   1        //if(SYSTYPE == PCT_DetectVideoFormat(SENSORCHANNEL)) return true;//Kane canceled
 712   1        if(TempSystem == NONE_SYSTEM)
 713   1          return FALSE;
 714   1        if(TempSystem == SYSTYPE)
 715   1          return TRUE;
 716   1      
 717   1        SYSTYPE = TempSystem;
 718   1        //Kane Add<<<<
 719   1        //SYSTYPE = PCT_DetectVideoFormat(SENSORCHANNEL);//Kane canceled
 720   1        SYSMIXTYP = (SYSTYPE<<7)|(SYSMIXTYP&0x7F);
 721   1      
 722   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 723   1        // ------------- Control Video ------------
 724   1        PCT_ChangeSystemType(SYSTYPE);
 725   1        PCT_RecompenseYHdelay(SYSCHATTR); // preset Y Recompense
 726   1        PCT_SetVideoHDelay(RECWINTYPE, WINCH, SYSWINATTR);
 727   1        
 728   1        PCT_SetXVideoMixing(RECWINTYPE, WINCH);
 729   1        //PCT_VideoLastModify();
 730   1        // ------------- Control OSD ------------
 731   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 732   1        PCT_ShowModeIcon();
 733   1        PCT_OSD_ActionPthX(SYSWINATTR);
 734   1        PCT_OSDActionForHS();
 735   1        // --------------------------------------
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 13  

 736   1        return TRUE;  //Pinchi 20150323 add for compiler warning
 737   1      }
 738          
 739          // ***************************************************************************
 740          //
 741          // Command Shell for HiSarp Setting S or J Mode
 742          //
 743          void MoniHSCommSJmode(PCHAR szParam)
 744          {
 745   1        sscanf(szParam, "%bd ", &SYSMODE);
 746   1      }
 747          
 748          // ***************************************************************************
 749          //
 750          // Command Shell for HiSarp Setting S or J Mode
 751          //
 752          void MoniHSCommDisScroll(void)
 753          {
 754   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 755   1      }
 756          
 757          // ***************************************************************************
 758          //
 759          // Command Shell for HiSarp Setting S or J Mode
 760          //
 761          #if 1  //Pinchi 20150415 add
 762          void MoniHSCommVersion(void)
 763          {
 764   1        U8 version=0;
 765   1      
 766   1      #if (TW2835_MCU == TW8816_MODEL_MEGAWIN)  //Pinchi 20150415 add
 767   1        RS_tx('M');
 768   1      #else
                RS_tx('W');
              #endif
 771   1        //RS_tx(VERSION[0]-'0');
 772   1        //version = (VERSION[1]-'0')*10 + (VERSION[2]-'0');
 773   1        //RS_tx(version);
 774   1        RS_tx(VERSION[0]);
 775   1        RS_tx(VERSION[1]);
 776   1        RS_tx(VERSION[2]);
 777   1        RS_tx(VIDEO_SYS);//ryan@20180417
 778   1        
 779   1      }
 780          #else
              void MoniHSCommVersion(void)
              {
                RS_tx(VERSION[0]);
                RS_tx(VERSION[1]);
              }
              #endif
 787          
 788          // ***************************************************************************
 789          //
 790          // Runing Command Shell
 791          //
 792          
 793          U8 PCT_RunCommShell(char *strptr)
 794          {
 795   1        data U16 commcode;
 796   1        char *getStr;
 797   1          
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 14  

 798   1        // ---------- Run Command Shell Entry ----------
 799   1        //Kane @HS 2007 0809 Ver3.5>>>>
 800   1        PCT_GetFirstStr(&getStr, &strptr);
 801   1        //getStr=strptr+4;
 802   1        //Kane @HS 2007 0809 Ver3.5<<<<
 803   1        commcode = PCT_StrToCommCode(getStr); 
 804   1        
 805   1        if (commcode == PCT_StrToCommCode("&")) {
 806   2          //printf("Read Page Buffer Data");
 807   2          MoniReadPageBuffer(strptr);
 808   2        }else if( commcode == PCT_StrToCommCode("(")) {
 809   2          //printf("Read One Buffer Data");
 810   2          MoniReadOneBuffer(strptr);
 811   2        }else if( commcode == PCT_StrToCommCode(")")) {
 812   2          //printf("Write One Buffer Data");
 813   2          MoniWriteOneBuffer(strptr);
 814   2        }else if( commcode == PCT_StrToCommCode("busw")) {
 815   2          // ===== ASICBUS Write Byte ======
 816   2          //printf("Command is Write Bus");
 817   2          MoniWriteAsicByte(strptr);
 818   2        } else if (commcode == PCT_StrToCommCode("busr")) {
 819   2          // ===== ASICBUS Read Byte =======
 820   2          //printf("Command is Read Bus");
 821   2          MoniReadAsicByte(strptr);
 822   2        } else if (commcode == PCT_StrToCommCode("amix")) {
 823   2          // ===== Audio mix =======
 824   2          //printf("Command is Audio Mixing");
 825   2          MoniAudioMixing(strptr);
 826   2        } else if (commcode == PCT_StrToCommCode("amute")) {
 827   2          // ===== Audio Mute =======
 828   2          //printf("Command is Audio Mute");
 829   2          MoniAudioMute();
 830   2        } else if (commcode == PCT_StrToCommCode("adump")) {
 831   2          // ===== List Audio Register Value =======
 832   2          //printf("List Audio Register Value");
 833   2          PCT_AudioRegList();
 834   2        } else if (commcode == PCT_StrToCommCode("again")) {
 835   2          // ===== Audio Gain Control =======
 836   2          //printf("Audio Gain Control");
 837   2          MoniAudioGain(strptr);
 838   2        } else if (commcode == PCT_StrToCommCode("alive")) {
 839   2          // ===== Audio Select Live & Mixing Mode =======
 840   2          //printf("Audio Select Live & Mixing Mode");
 841   2          MoniAudioLive(strptr);
 842   2        } else if (commcode == PCT_StrToCommCode("busrt")) {
 843   2          // ===== All Register Dump =======
 844   2          //printf("All Register Dump");
 845   2          MoniRegisterDump();
 846   2        } else if (commcode == PCT_StrToCommCode("vmix")) {
 847   2          // ===== Video Mix's Windows Type Select =======
 848   2          //printf("Video Mix's Windows Type Select");
 849   2          PCT_WinAttrClear(WIN_FREEZE);
 850   2          MoniVideoMixWin(strptr);
 851   2          PCT_SendACK();
 852   2        } else if (commcode == PCT_StrToCommCode("vmixerr")) {
 853   2          // ===== Video Mix's Windows Type Select =======
 854   2          //printf("Video Mixerr's Windows Type Select");
 855   2          MoniVideoMixWin(strptr); 
 856   2        } else if (commcode == PCT_StrToCommCode("vattr")) {
 857   2          // ===== Video Mixing Control =======
 858   2          //printf("Video Attribute Control");
 859   2          MoniVideoMixAttr(strptr);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 15  

 860   2        } else if (commcode == PCT_StrToCommCode("yvmix")) {    // HiSharp has used
 861   2          // ===== Video Mixing Control =======
 862   2          PCT_SendACK();
 863   2          //printf("Video Attribute Control");
 864   2          MoniYVideoMix(strptr);
 865   2        } else if (commcode == PCT_StrToCommCode("init")) {
 866   2          // ===== TW2835 initial =======
 867   2          //printf("Initial TW2835");
 868   2          PCT_InitialTW2835();
 869   2        } else if (commcode == PCT_StrToCommCode("vdet")) {
 870   2          // ===== Video Mixing Control =======
 871   2          //printf("Auto Detectation Video Format");
 872   2          MoniVideoAutoDetect();
 873   2        } else if (commcode == PCT_StrToCommCode("vsetf")) {
 874   2          // ===== Video Mixing Control =======
 875   2          //printf("Setting Video Format Control");
 876   2          MoniSetVideoFormat(strptr);
 877   2        } else if (commcode == PCT_StrToCommCode("sstr")) {
 878   2          // ===== Show String on OSD =======
 879   2          //printf("Show String on OSD");
 880   2          MoniShowSODStr(strptr);
 881   2      // --------------------------------------------------------------------------------
 882   2        } else if (commcode == PCT_StrToCommCode("hscom")) {    // HiSharp has used
 883   2          PCT_SendACK();
 884   2          //printf("Command Shell for HiSharp");
 885   2          MoniHSComm(strptr);
 886   2      
 887   2          PCT_AudioActionForHS();
 888   2          PCT_OSDActionForHS();
 889   2          PCT_FlashOSDCtrl(OFF);
 890   2          
 891   2        //  VlossFlag = 0;  //ryan@20150318
 892   2        #ifdef AWT_NO_SIGNAL_MSG  //Pinchi 20150326 add
 893   2          DisUserTimer(USERTMID1);
 894   2          EnUserTimer(USERTMID0,5); 
 895   2      
 896   2        #endif
 897   2        } else if (commcode == PCT_StrToCommCode("mode")) {     // HiSharp has used
 898   2          PCT_SendACK();
 899   2          //printf("Command Shell for HiSharp Set S or J Mode");
 900   2          MoniHSCommSJmode(strptr);
 901   2        } else if (commcode == PCT_StrToCommCode("disscroll")) {  // HiSharp has used
 902   2          PCT_SendACK();
 903   2          //printf("Command Shell for HiSharp Disable Scroll!");
 904   2          MoniHSCommDisScroll();
 905   2        } else if (commcode == PCT_StrToCommCode("ver")) {  // HiSharp has used
 906   2          PCT_SendACK();
 907   2          //printf("Command Shell for HiSharp Disable Scroll!");
 908   2          MoniHSCommVersion();
 909   2          #if (TW2837_DEBUG==ON)
                  if(access==1)
                    {
                    access=0;
                    Printf("\r\nACCESS=0");           
                    }
                  else
                    {
                    access=1;
                    Printf("\r\nACCESS=1");           
                    }
                  #endif
 921   2          //PCT_InitialTW2835();//Kane @HS 2007 0723 Ver3.4
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      06/28/2021 14:11:42 PAGE 16  

 922   2      // --------------------------------------------------------------------------------
 923   2        } else {
 924   2        }
 925   1      
 926   1        // ---------------------------------------------
 927   1        return true;
 928   1      }
 929          
 930          
 931          // ===========================================================================
 932          // END of File 
 933          // ===========================================================================
 934          
 935          
 936          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4305    ----
   CONSTANT SIZE    =    735    ----
   XDATA SIZE       =     26      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      72
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
