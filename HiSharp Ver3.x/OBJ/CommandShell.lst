C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE COMMANDSHELL
OBJECT MODULE PLACED IN .\OBJ\CommandShell.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE CommandShell.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\OBJ\CommandShell.lst) TABS(2) OBJECT(.\OBJ\CommandShell.obj)

line level    source

   1          //  **************************************************************************
   2          //
   3          //       Copyright (c) 1992-2006 Professonal Computer Technology Co., Ltd
   4          //
   5          //      All rights are reserved. Reproduction in whole or in parts is
   6          //  prohibited without the prior written consent of the copyright owner.
   7          //  --------------------------------------------------------------------------
   8          //
   9          //  Module: CommandSell.C
  10          //
  11          //  Purpose: Implementation of CommandSell.
  12          //
  13          //  Version: 0.01                                   2006/10/22 10:39¤U¤È
  14          //
  15          //  Compiler: Keil 8051 C Compiler v7.2
  16          //
  17          //  Reference:
  18          //
  19          //
  20          //
  21          //  --------------------------------------------------------------------------
  22          //  Modification:
  23          //
  24          //  R0.01 2006/10/22 10:39¤U¤È Phoenix Chuang
  25          //  Reason:
  26          //    1. Original.
  27          //  Solution:
  28          //  
  29          //  **************************************************************************
  30          //  -----------------------------------
  31          //      Header Files
  32          //  ----------------------------------- 
  33          #include "Types.h"
  34          #include "CommandShell.h"
  35          #include "UART.h"
  36          #include "Timer.h"
  37          #include "BusCtrl.h"
  38          #include "TW2835_Init.h"
  39          #include "TW28xx_Audio.h"
  40          #include "TW28xx_Video.h"
  41          #include "OSDCtrl.h"
  42          #include "OSDAction.h"
  43          #include "Main.h"
  44          
  45          #include "Printf.h"
  46          #include "monitor.h"
  47          
  48          // Table define on code
  49          
  50          
  51          //  ------------------------------------
  52          //      Macro Definitions
  53          //  ------------------------------------ 
  54          #define WINCH     sysdat.channel_link
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 2   

  55          #define RECWINTYPE  sysdat.video_mix_type
  56          #define RECLKTP     sysdat.link_type
  57          #define OSDREFALSH  msg.osd_falsh
  58          #define selwintype  msg.video_mix_type
  59            
  60          //  ------------------------------------
  61          //      Type Definitions
  62          //  ------------------------------------
  63          #if (TW2835_MCU == TW8806_MODEL_WINBOND)  //Pinchi 20150401 add
              #define VERSION "320"
              #else
  66            #if (defined UTC)
                #define VERSION "333"
                #elif (defined HS)
                  #ifdef HOLGER
                  #define VERSION "335" ///for Holger PAL
                  #else
                  #define VERSION "334"
                  #endif
                #else
  75            #define VERSION "337"
  76            #endif
  77          #endif
  78          
  79          #ifdef HOLGER
              #define VIDEO_SYS   'P' //NTSC
              #else
  82          #define VIDEO_SYS   'N' //NTSC
  83          #endif
  84          
  85          //  ------------------------------------
  86          //      Variables Definitions
  87          //  ------------------------------------
  88            SYS_DATA sysdat;
  89            SYS_MESSAGE msg;  
  90          #if (TW2837_DEBUG==ON)
  91            extern U8 access;
  92          #endif
  93          
  94            extern BYTE TW2837IDCheck;
  95          
  96          //  extern bit VlossFlag;//ryan@20150318
  97          
  98          //  ------------------------------------
  99          //      Function Prototypes
 100          //  ------------------------------------
 101          
 102          // ***************************************************************************
 103          
 104          // ===========================================================================
 105          //                      Parallel function description
 106          // ===========================================================================
 107          //
 108          // Get Command String from Command Buffer
 109          //
 110          U8 PCT_GetFirstStr(char **tagStr, char **sourceStr) 
 111          {
 112   1        if( **sourceStr == '\0' ) return false;
 113   1        while(**sourceStr == ' ' ) (*sourceStr)++;
 114   1        *tagStr = *sourceStr;
 115   1        (*sourceStr)++;
 116   1        while(1) {
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 3   

 117   2          if( **sourceStr==' ' ) {
 118   3            **sourceStr = '\0';
 119   3            (*sourceStr)++;
 120   3            return true;
 121   3          } else if( **sourceStr == '\0' ) {
 122   3            return true;
 123   3          } else (*sourceStr)++;
 124   2        }
 125   1      }
 126          
 127          // ===========================================================================
 128          //
 129          // String Transfer to Command Code 
 130          //
 131          U16 PCT_StrToCommCode(char *Str)
 132          {
 133   1        data U16 ret=0;
 134   1        
 135   1        while(*Str != '\0' ) ret+=*Str++;
 136   1        return ret;
 137   1      }
 138          
 139          // ===========================================================================
 140          //
 141          // Send ACK to TW8806
 142          //
 143          void PCT_SendACK(void)
 144          {
 145   1        RS_tx('A');
 146   1        RS_tx('C');
 147   1        RS_tx('K');
 148   1      }
 149          
 150          // ===========================================================================
 151          //
 152          // ===========================================================================
 153          //
 154          void PCT_CheckVMixType(U8 _typ)
 155          {
 156   1        data U8 tmplktp=0;
 157   1        
 158   1        tmplktp += (WINCH[0]&0x03); 
 159   1        tmplktp += (WINCH[1]&0x03)<<2; 
 160   1        tmplktp += (WINCH[2]&0x03)<<4; 
 161   1        tmplktp += (WINCH[3]&0x03)<<6; 
 162   1        
 163   1        if((RECWINTYPE==_typ)&&(tmplktp==RECLKTP)) {
 164   2          OSDREFALSH = OFF;
 165   2          return; 
 166   2        }
 167   1        OSDREFALSH = ON;
 168   1        RECLKTP = tmplktp;
 169   1        RECWINTYPE = _typ;
 170   1      }
 171          
 172          // ===========================================================================
 173          
 174          // ***************************************************************************
 175          // Process Command Shell Function
 176          // ***************************************************************************
 177          //
 178          // This is to communicate with PC AP 
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 4   

 179          //
 180          void MoniReadPageBuffer(PCHAR szParam)
 181          {
 182   1        data U8 page, start, end;
 183   1      
 184   1        sscanf(szParam, "%bx %bx %bx", &page, &start, &end); 
 185   1      
 186   1        do {
 187   2          printf("\n<R>%02bx[%02bx]=%02bx", page, start, TW28_ReadByte(page, start) );
 188   2          start++;
 189   2        }while(start != end);
 190   1      }
 191          
 192          // ***************************************************************************
 193          //
 194          // This is to communicate with PC AP 
 195          //
 196          void MoniReadOneBuffer(PCHAR szParam)
 197          {
 198   1        data U8 page, addr;
 199   1      
 200   1        sscanf(szParam, "%bx %bx", &page, &addr); 
 201   1      
 202   1        printf("\n<R>%02bx[%02bx]=%02bx", page, addr, TW28_ReadByte(page, addr) );
 203   1      }
 204          
 205          // ***************************************************************************
 206          //
 207          // This is to communicate with PC AP 
 208          //
 209          void MoniWriteOneBuffer(PCHAR szParam)
 210          {
 211   1        data U8 page, addr, dat;
 212   1      
 213   1        sscanf(szParam, "%bx %bx %bx", &page, &addr, &dat); 
 214   1        TW28_WriteByte(page, addr, dat);
 215   1      }
 216          
 217          // ***************************************************************************
 218          //
 219          // Monitor ASCIBUS Write Byte
 220          //
 221          void MoniWriteAsicByte(PCHAR szParam)
 222          {
 223   1        data U8 _dev=0;
 224   1        data U8 _pg=0;
 225   1        data U8 _addr=0;
 226   1        data U8 _wdat=0;
 227   1        
 228   1        sscanf(szParam, "%bx %bx %bx %bx ", &_dev, &_pg, &_addr, &_wdat);
 229   1        TW28_WriteByte(_pg, _addr, _wdat);
 230   1      }
 231          
 232          // ***************************************************************************
 233          //
 234          // Monitor ASCIBUS Write Byte
 235          //
 236          void MoniReadAsicByte(PCHAR szParam)
 237          {
 238   1        data U8 _dev=0;
 239   1        data U8 _pg=0;
 240   1        data U8 _addr=0;
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 5   

 241   1        data U8 _rdat=0;
 242   1        
 243   1        sscanf(szParam, "%1bx %1bx %1bx ", &_dev, &_pg, &_addr);
 244   1        _rdat = TW28_ReadByte(_pg, _addr);
 245   1        printf("ReadAsicByte == %bx \n", _rdat);
 246   1      }
 247          
 248          // ***************************************************************************
 249          //
 250          // Monitor Audio Mixing 
 251          // Format : amix N ch0:val ch1:val ch2:val ch3:val ch4:val 
 252          //
 253          void MoniAudioMixing(PCHAR szParam)
 254          {
 255   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 256   1        data U8 valch0,valch1,valch2,valch3,valch4; 
 257   1        char *getStr;
 258   1        code U8 chaddr[] = {ADO_MIX_MUTE_AIN0, \
 259   1                  ADO_MIX_MUTE_AIN1, \
 260   1                  ADO_MIX_MUTE_AIN2, \
 261   1                  ADO_MIX_MUTE_AIN3, \
 262   1                  ADO_MIX_MUTE_PBAI \
 263   1        };  
 264   1      
 265   1        PCT_GetFirstStr(&getStr,&szParam);
 266   1      
 267   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 268   1                  ADO_MIX_MUTE_AIN1+ \
 269   1                  ADO_MIX_MUTE_AIN2+ \
 270   1                  ADO_MIX_MUTE_AIN3+ \
 271   1                  ADO_MIX_MUTE_PBAI, OFF);
 272   1      
 273   1        switch( atoi(getStr) ) {
 274   2        case 1:
 275   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 276   2          PCT_AudioMixCtrl(0, selch0, valch0);
 277   2          PCT_AudioMixMute(0, chaddr[selch0], ON);
 278   2          break;
 279   2        
 280   2        case 2:
 281   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 282   2            &selch0, &valch0, &selch1, &valch1);
 283   2          PCT_AudioMixCtrl(0, selch0, valch0);
 284   2          PCT_AudioMixCtrl(0, selch1, valch1);
 285   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1], ON);
 286   2          break;
 287   2        
 288   2        case 3:
 289   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 290   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 291   2          PCT_AudioMixCtrl(0, selch0, valch0);
 292   2          PCT_AudioMixCtrl(0, selch1, valch1);
 293   2          PCT_AudioMixCtrl(0, selch2, valch2);
 294   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2], ON);
 295   2          break;
 296   2        
 297   2        case 4:
 298   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 299   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 300   2          PCT_AudioMixCtrl(0, selch0, valch0);
 301   2          PCT_AudioMixCtrl(0, selch1, valch1);
 302   2          PCT_AudioMixCtrl(0, selch2, valch2);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 6   

 303   2          PCT_AudioMixCtrl(0, selch3, valch3);
 304   2      
 305   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3], ON);
 306   2          break;
 307   2      
 308   2        case 5:
 309   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 310   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3,  &selch4, &valch4 );
 311   2          PCT_AudioMixCtrl(0, selch0, valch0);
 312   2          PCT_AudioMixCtrl(0, selch1, valch1);
 313   2          PCT_AudioMixCtrl(0, selch2, valch2);
 314   2          PCT_AudioMixCtrl(0, selch3, valch3);
 315   2          PCT_AudioMixCtrl(0, selch4, valch4);
 316   2      
 317   2          PCT_AudioMixMute(0, chaddr[selch0]+chaddr[selch1]+chaddr[selch2]+chaddr[selch3]+chaddr[selch4], ON);
 318   2          break;
 319   2        
 320   2        default:
 321   2          break;
 322   2        }
 323   1      }
 324          
 325          // ***************************************************************************
 326          //
 327          // Monitor Audio Mute 
 328          // Format : amute
 329          //
 330          void MoniAudioMute(void)
 331          {
 332   1        PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 333   1                  ADO_MIX_MUTE_AIN1+ \
 334   1                  ADO_MIX_MUTE_AIN2+ \
 335   1                  ADO_MIX_MUTE_AIN3+ \
 336   1                  ADO_MIX_MUTE_PBAI, OFF);
 337   1        PCT_AudioSelLive(0, 0xFF);
 338   1      }
 339          
 340          // ***************************************************************************
 341          //
 342          // Monitor Audio Mixing 
 343          // Format : again N ch0:val ch1:val ch2:val ch3:val ch5:val
 344          //
 345          void MoniAudioGain(PCHAR szParam)
 346          {
 347   1        data U8 selch0,selch1,selch2,selch3,selch4; 
 348   1        data U8 ch0val,ch1val,ch2val,ch3val,ch4val; 
 349   1        char *getStr;
 350   1      
 351   1        PCT_GetFirstStr(&getStr,&szParam);
 352   1      
 353   1        switch( atoi(getStr) ) {
 354   2        case 1:
 355   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&ch0val);
 356   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 357   2          break;
 358   2        
 359   2        case 2:
 360   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 361   2            &selch0, &ch0val, &selch1, &ch1val);
 362   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 363   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 364   2          break;
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 7   

 365   2        
 366   2        case 3:
 367   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 368   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val);
 369   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 370   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 371   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 372   2          break;
 373   2        
 374   2        case 4:
 375   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 376   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val);
 377   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 378   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 379   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 380   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 381   2          break;
 382   2        
 383   2        case 5:
 384   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 385   2            &selch0, &ch0val, &selch1, &ch1val, &selch2, &ch2val, &selch3, &ch3val, &selch4, &ch4val);
 386   2          PCT_AudioGainCtrl(0, selch0, ch0val);
 387   2          PCT_AudioGainCtrl(0, selch1, ch1val);
 388   2          PCT_AudioGainCtrl(0, selch2, ch2val);
 389   2          PCT_AudioGainCtrl(0, selch3, ch3val);
 390   2          PCT_AudioGainCtrl(0, selch4, ch4val);
 391   2          break;
 392   2        
 393   2        default:
 394   2          break;
 395   2        }
 396   1      }
 397          
 398          // ***************************************************************************
 399          //
 400          // Monitor Select Live or Mixing Mode 
 401          // alive chan (chan=0xFF is Mixing Mode)
 402          //
 403          void MoniAudioLive(PCHAR szParam)
 404          {
 405   1        data U8 chan;
 406   1      
 407   1        sscanf(szParam, "%bd ", &chan);
 408   1      
 409   1        PCT_AudioSelLive(0,chan);
 410   1      }
 411          
 412          // ***************************************************************************
 413          //
 414          // TW2835 Register All Dump
 415          //
 416          void MoniRegisterDump(void)
 417          {
 418   1        data U8 addr,page;
 419   1        
 420   1      
 421   1        for(page=0;page<3;page++) {
 422   2          printf("\n ======== PAGE %b2x =============\n",page);
 423   2          addr = 0;
 424   2          do {
 425   3            printf("%b2x\t", TW28_ReadByte(page, addr));
 426   3            addr++;
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 8   

 427   3            if((addr%16)==0)  printf("\n"); 
 428   3          } while( addr );
 429   2        }
 430   1      }
 431          
 432          // ***************************************************************************
 433          //
 434          // video signal mixing to windows
 435          //
 436          void MoniVideoMixWin(PCHAR szParam)
 437          {
 438   1        data U8 chose,wintp;
 439   1      
 440   1        sscanf(szParam, "%1bx %1bx ch%1bx ch%1bx ch%1bx ch%1bx ",
 441   1                &chose, &wintp, &WINCH[0], &WINCH[1], &WINCH[2], &WINCH[3]);
 442   1        chose = (chose<<4)+(wintp&0x0F);
 443   1        PCT_SetXVideoMixing(chose, WINCH);  
 444   1      }
 445          
 446          // ***************************************************************************
 447          //
 448          // setting windows attribute
 449          //
 450          void MoniVideoMixAttr(PCHAR szParam)
 451          {
 452   1        data U16 chose;
 453   1        data U8 attrsel,setval;
 454   1        data U8   winNm[4],wincnt=0;
 455   1        data U8   division;
 456   1        char *getStr;
 457   1      
 458   1        PCT_GetFirstStr(&getStr,&szParam);
 459   1        division = atoi(getStr); 
 460   1      
 461   1        PCT_GetFirstStr(&getStr,&szParam);
 462   1        chose = PCT_StrToCommCode(getStr); 
 463   1      
 464   1        if( chose==PCT_StrToCommCode("enrecall") ) {
 465   2          attrsel = WIN_RECALL_EN;
 466   2          setval  = ON;
 467   2        } else if ( chose==PCT_StrToCommCode("enfreeze") ) {
 468   2          attrsel = WIN_FREEZE;
 469   2          setval  = ON;
 470   2        } else if ( chose==PCT_StrToCommCode("enhmirror") ) {
 471   2          attrsel = WIN_HMIRROR;
 472   2          setval  = ON;
 473   2        } else if ( chose==PCT_StrToCommCode("envmirror") ) {
 474   2          attrsel = WIN_VMIRROR;
 475   2          setval  = ON;
 476   2        } else if ( chose==PCT_StrToCommCode("enenhance") ) {
 477   2          attrsel = WIN_ENHANCE;
 478   2          setval  = ON;
 479   2        } else if ( chose==PCT_StrToCommCode("enblank") ) {
 480   2          attrsel = WIN_BLANK;
 481   2          setval  = ON;
 482   2        } else if ( chose==PCT_StrToCommCode("enbound") ) {
 483   2          attrsel = WIN_BOUND;
 484   2          setval  = ON;
 485   2        } else if ( chose==PCT_StrToCommCode("enblink") ) {
 486   2          attrsel = WIN_BLINK;
 487   2          setval  = ON;
 488   2        } else if ( chose==PCT_StrToCommCode("disrecall") ) {
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 9   

 489   2          attrsel = WIN_RECALL_EN;
 490   2          setval  = OFF;
 491   2        } else if ( chose==PCT_StrToCommCode("disfreeze") ) {
 492   2          attrsel = WIN_FREEZE;
 493   2          setval  = OFF;
 494   2        } else if ( chose==PCT_StrToCommCode("dishmirror") ) {
 495   2          attrsel = WIN_HMIRROR;
 496   2          setval  = OFF;
 497   2        } else if ( chose==PCT_StrToCommCode("disvmirror") ) {
 498   2          attrsel = WIN_VMIRROR;
 499   2          setval  = OFF;
 500   2        } else if ( chose==PCT_StrToCommCode("disenhance") ) {
 501   2          attrsel = WIN_ENHANCE;
 502   2          setval  = OFF;
 503   2        } else if ( chose==PCT_StrToCommCode("disblank") ) {
 504   2          attrsel = WIN_BLANK;
 505   2          setval  = OFF;
 506   2        } else if ( chose==PCT_StrToCommCode("disbound") ) {
 507   2          attrsel = WIN_BOUND;
 508   2          setval  = OFF;
 509   2        } else if ( chose==PCT_StrToCommCode("disblink") ) {
 510   2          attrsel = WIN_BLINK;
 511   2          setval  = OFF;
 512   2        } else {
 513   2          return;
 514   2        }
 515   1      
 516   1        while( PCT_GetFirstStr(&getStr,&szParam) ) {
 517   2          if(*getStr=='w' && *(getStr+1)=='i' && *(getStr+2)=='n') 
 518   2          {
 519   3            winNm[wincnt] = atoi(getStr+3);
 520   3            wincnt++;
 521   3          }
 522   2        }
 523   1        for( ; wincnt!=0; wincnt--) {
 524   2          if( winNm[wincnt-1]<division ) {
 525   3            PCT_WinAttrCtrl(winNm[wincnt-1], attrsel, setval);
 526   3          }
 527   2        }
 528   1      }
 529          
 530          // ***************************************************************************
 531          //
 532          // Monitor Video Y Channel Select Live or Mixing Mode 
 533          // yvmix chan (chan=0x04 is Mixing Mode)
 534          //
 535          void MoniYVideoMix(PCHAR szParam)
 536          {
 537   1        data U8 chan;
 538   1      
 539   1        sscanf(szParam, "%bd ", &chan);
 540   1        PCT_SetYVideoMixing(chan);
 541   1      }
 542          
 543          // ***************************************************************************
 544          //
 545          // Monitor Video Auto Detect Format 
 546          //
 547          void MoniVideoAutoDetect(void)
 548          {
 549   1        printf("===== Format : ch0=[%bx] ch1=[%bx] ch2=[%bx] ch3=[%bx] =====\n",  \ 
 550   1            PCT_DetectVideoFormat(0x00), \
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 10  

 551   1            PCT_DetectVideoFormat(0x01), \
 552   1            PCT_DetectVideoFormat(0x02), \
 553   1            PCT_DetectVideoFormat(0x03) \
 554   1        );
 555   1      }
 556          
 557          // ***************************************************************************
 558          //
 559          // Monitor Setting Video Format 
 560          //
 561          void MoniSetVideoFormat(PCHAR szParam)
 562          {
 563   1        data U8 selch0,selch1,selch2,selch3;  
 564   1        data U8 valch0,valch1,valch2,valch3;  
 565   1        char *getStr;
 566   1      
 567   1        PCT_GetFirstStr(&getStr,&szParam);
 568   1      
 569   1        switch( atoi(getStr) ) {
 570   2        case 1:
 571   2          sscanf(szParam,"ch%bd:%bd ",&selch0,&valch0);
 572   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 573   2          break;
 574   2        
 575   2        case 2:
 576   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ", \
 577   2            &selch0, &valch0, &selch1, &valch1);
 578   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 579   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 580   2          break;
 581   2        
 582   2        case 3:
 583   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 584   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2);
 585   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 586   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 587   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 588   2          break;
 589   2        
 590   2        case 4:
 591   2          sscanf(szParam,"ch%bd:%bd ch%bd:%bd ch%bd:%bd ch%bd:%bd ", \
 592   2            &selch0, &valch0, &selch1, &valch1, &selch2, &valch2, &selch3, &valch3);
 593   2          PCT_SetVideoFormat(0, selch0, valch0<<4);
 594   2          PCT_SetVideoFormat(0, selch1, valch1<<4);
 595   2          PCT_SetVideoFormat(0, selch2, valch2<<4);
 596   2          PCT_SetVideoFormat(0, selch3, valch3<<4);
 597   2          break;
 598   2      
 599   2        default:
 600   2          break;
 601   2        }
 602   1      }
 603          
 604          // ***************************************************************************
 605          //
 606          // Monitor Setting Video Format 
 607          //
 608          void MoniShowSODStr(PCHAR szParam)
 609          {
 610   1        data U8 addrx,addry;
 611   1        char *getStr;
 612   1        
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 11  

 613   1        PCT_GetFirstStr(&getStr,&szParam);
 614   1        addrx=atoi(getStr);
 615   1        PCT_GetFirstStr(&getStr,&szParam);
 616   1        addry=atoi(getStr);
 617   1      
 618   1        PCT_PreSetForegroundColor(OSD_COL_100WHT);
 619   1        PCT_PreSetBackgroundColor(OSD_COL_BLU);
 620   1        PCT_SetOSDDrawPage(WRPHX_PAGE5);
 621   1        PCT_ShowOSDString(PTH_X, addrx, addry, szParam);
 622   1        PCT_EnShowOSDPage(WRPHX_PAGE5);
 623   1      }
 624          
 625          // ***************************************************************************
 626          //
 627          // Audio Control for HiSarp
 628          //
 629          void PCT_AudioActionForHS(void)
 630          {
 631   1        data U8 winid;
 632   1        data U8 muteFlage=true;
 633   1      
 634   1        // ------------- Control Audio ------------
 635   1        for(winid=0; winid<4; winid++) {
 636   2          if(SYSWINATTR[winid]&BIT4) {
 637   3            PCT_AudioSelLive(0,WINCH[winid]);
 638   3            muteFlage = false;
 639   3          }
 640   2        }
 641   1      
 642   1        if(muteFlage) {
 643   2          // Audio Mute
 644   2          PCT_AudioMixMute(0, ADO_MIX_MUTE_AIN0+ \
 645   2                    ADO_MIX_MUTE_AIN1+ \
 646   2                    ADO_MIX_MUTE_AIN2+ \
 647   2                    ADO_MIX_MUTE_AIN3+ \
 648   2                    ADO_MIX_MUTE_PBAI, OFF);
 649   2          PCT_AudioSelLive(0, 0xFF);
 650   2        }
 651   1        // ----------------------------------------
 652   1      }
 653          
 654          // ***************************************************************************
 655          //
 656          // Command Shell for HiSarp
 657          //
 658          BYTE xdata Original_selwintype = 0;//Kane @HS 2007 0724 Ver3.4
 659          void MoniHSComm(PCHAR szParam) {
 660   1        data U8 winid;
 661   1        data U8 chose,wintp;
 662   1        
 663   1        sscanf(szParam, "%bx %bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ch%bx:%bx ",
 664   1                &chose, &wintp, &WINCH[0], &SYSWINATTR[0], &WINCH[1], &SYSWINATTR[1], &WINCH[2], &SYSWINATTR[2], &WIN
             -CH[3], &SYSWINATTR[3]);
 665   1      
 666   1        selwintype = (SYSTYPE<<7)+(chose<<4)+(wintp&0x0F);
 667   1      
 668   1        // ----------- Y Chanle setting windows horizontal mirror ----------
 669   1          
 670   1        SYSCHATTR[WINCH[0]]=SYSWINATTR[0];
 671   1        SYSCHATTR[WINCH[1]]=SYSWINATTR[1];
 672   1        SYSCHATTR[WINCH[2]]=SYSWINATTR[2];
 673   1        SYSCHATTR[WINCH[3]]=SYSWINATTR[3];
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 12  

 674   1      
 675   1        PCT_WinAttrCtrlY(0, WIN_HMIRROR, SYSCHATTR[0]&BIT0);  
 676   1        PCT_WinAttrCtrlY(1, WIN_HMIRROR, SYSCHATTR[1]&BIT0);  
 677   1        PCT_WinAttrCtrlY(2, WIN_HMIRROR, SYSCHATTR[2]&BIT0);  
 678   1        PCT_WinAttrCtrlY(3, WIN_HMIRROR, SYSCHATTR[3]&BIT0);  
 679   1        // -----------------------------------------------------------------
 680   1      
 681   1        // ------------- Control Video ------------
 682   1        //if(Original_selwintype != selwintype)//Kane @HS 2007 0724 Ver3.4
 683   1        PCT_RecompenseYHdelay(SYSCHATTR);
 684   1        PCT_SetVideoHDelay(selwintype, WINCH, SYSWINATTR);
 685   1        
 686   1        PCT_SetXVideoMixing(selwintype, WINCH);
 687   1        //PCT_VideoLastModify();
 688   1        for(winid=0; winid<4; winid++) 
 689   1          PCT_WinAttrCtrl(winid, WIN_HMIRROR, SYSWINATTR[winid]&BIT0);
 690   1        // ----------------------------------------
 691   1      
 692   1        // ------------- Control OSD ------------
 693   1        DisUserTimer(USERTMID0);    // Disable real-time detect VLoss
 694   1        EnUserTimer(USERTMID1,5);   // Enable OSD Delay Timer
 695   1        PCT_FlashOSDCtrl(ON);
 696   1        PCT_CheckVMixType(selwintype);
 697   1        PCT_DisShowOSDPage(DISOSD_PHX);
 698   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 699   1        PCT_ShowModeIcon();
 700   1        PCT_OSD_ActionPthX(SYSWINATTR);
 701   1        Original_selwintype = selwintype;//Kane @HS 2007 0724 Ver3.4
 702   1        // --------------------------------------
 703   1      }
 704          
 705          // ***************************************************************************
 706          //
 707          // Real Time Check System Type PAL or NTSC
 708          //
 709          bit PCT_CheckSystem(void)
 710          {
 711   1        //Kane add>>>>
 712   1        char TempSystem;
 713   1        TempSystem = PCT_DetectVideoFormat(SENSORCHANNEL);
 714   1        //if(SYSTYPE == PCT_DetectVideoFormat(SENSORCHANNEL)) return true;//Kane canceled
 715   1        if(TempSystem == NONE_SYSTEM)
 716   1          return FALSE;
 717   1        if(TempSystem == SYSTYPE)
 718   1          return TRUE;
 719   1      
 720   1        SYSTYPE = TempSystem;
 721   1        //Kane Add<<<<
 722   1        //SYSTYPE = PCT_DetectVideoFormat(SENSORCHANNEL);//Kane canceled
 723   1        SYSMIXTYP = (SYSTYPE<<7)|(SYSMIXTYP&0x7F);
 724   1      
 725   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 726   1        // ------------- Control Video ------------
 727   1        PCT_ChangeSystemType(SYSTYPE);
 728   1        PCT_RecompenseYHdelay(SYSCHATTR); // preset Y Recompense
 729   1        PCT_SetVideoHDelay(RECWINTYPE, WINCH, SYSWINATTR);
 730   1        
 731   1        PCT_SetXVideoMixing(RECWINTYPE, WINCH);
 732   1        //PCT_VideoLastModify();
 733   1        // ------------- Control OSD ------------
 734   1        PCT_ClearOSDPageX(WRPHX_PAGE0);
 735   1        PCT_ShowModeIcon();
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 13  

 736   1        PCT_OSD_ActionPthX(SYSWINATTR);
 737   1        PCT_OSDActionForHS();
 738   1        // --------------------------------------
 739   1        return TRUE;  //Pinchi 20150323 add for compiler warning
 740   1      }
 741          
 742          // ***************************************************************************
 743          //
 744          // Command Shell for HiSarp Setting S or J Mode
 745          //
 746          void MoniHSCommSJmode(PCHAR szParam)
 747          {
 748   1        sscanf(szParam, "%bd ", &SYSMODE);
 749   1      }
 750          
 751          // ***************************************************************************
 752          //
 753          // Command Shell for HiSarp Setting S or J Mode
 754          //
 755          void MoniHSCommDisScroll(void)
 756          {
 757   1        PCT_EnShowOSDPage(WRPHX_PAGE1);
 758   1      }
 759          
 760          // ***************************************************************************
 761          //
 762          // Command Shell for HiSarp Setting S or J Mode
 763          //
 764          #if 1  //Pinchi 20150415 add
 765          void MoniHSCommVersion(void)
 766          {
 767   1        U8 version=0;
 768   1      
 769   1      #if (TW2835_MCU == TW8816_MODEL_MEGAWIN)  //Pinchi 20150415 add
 770   1        RS_tx('M');
 771   1      #else
                RS_tx('W');
              #endif
 774   1        //RS_tx(VERSION[0]-'0');
 775   1        //version = (VERSION[1]-'0')*10 + (VERSION[2]-'0');
 776   1        //RS_tx(version);
 777   1        RS_tx(VERSION[0]);
 778   1        RS_tx(VERSION[1]);
 779   1        RS_tx(VERSION[2]);
 780   1        RS_tx(VIDEO_SYS);//ryan@20180417
 781   1      
 782   1        if(TW2837IDCheck==TRUE)
 783   1        {
 784   2          RS_tx('3');
 785   2          RS_tx('7');
 786   2        }
 787   1        else
 788   1          {
 789   2          RS_tx('3');
 790   2          RS_tx('5');
 791   2          }
 792   1        
 793   1      }
 794          #else
              void MoniHSCommVersion(void)
              {
                RS_tx(VERSION[0]);
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 14  

                RS_tx(VERSION[1]);
              }
              #endif
 801          
 802          // ***************************************************************************
 803          //
 804          // Runing Command Shell
 805          //
 806          
 807          U8 PCT_RunCommShell(char *strptr)
 808          {
 809   1        data U16 commcode;
 810   1        char *getStr;
 811   1          
 812   1        // ---------- Run Command Shell Entry ----------
 813   1        //Kane @HS 2007 0809 Ver3.5>>>>
 814   1        PCT_GetFirstStr(&getStr, &strptr);
 815   1        //getStr=strptr+4;
 816   1        //Kane @HS 2007 0809 Ver3.5<<<<
 817   1        commcode = PCT_StrToCommCode(getStr); 
 818   1        
 819   1        if (commcode == PCT_StrToCommCode("&")) {
 820   2          //printf("Read Page Buffer Data");
 821   2          MoniReadPageBuffer(strptr);
 822   2        }else if( commcode == PCT_StrToCommCode("(")) {
 823   2          //printf("Read One Buffer Data");
 824   2          MoniReadOneBuffer(strptr);
 825   2        }else if( commcode == PCT_StrToCommCode(")")) {
 826   2          //printf("Write One Buffer Data");
 827   2          MoniWriteOneBuffer(strptr);
 828   2        }else if( commcode == PCT_StrToCommCode("busw")) {
 829   2          // ===== ASICBUS Write Byte ======
 830   2          //printf("Command is Write Bus");
 831   2          MoniWriteAsicByte(strptr);
 832   2        } else if (commcode == PCT_StrToCommCode("busr")) {
 833   2          // ===== ASICBUS Read Byte =======
 834   2          //printf("Command is Read Bus");
 835   2          MoniReadAsicByte(strptr);
 836   2        } else if (commcode == PCT_StrToCommCode("amix")) {
 837   2          // ===== Audio mix =======
 838   2          //printf("Command is Audio Mixing");
 839   2          MoniAudioMixing(strptr);
 840   2        } else if (commcode == PCT_StrToCommCode("amute")) {
 841   2          // ===== Audio Mute =======
 842   2          //printf("Command is Audio Mute");
 843   2          MoniAudioMute();
 844   2        } else if (commcode == PCT_StrToCommCode("adump")) {
 845   2          // ===== List Audio Register Value =======
 846   2          //printf("List Audio Register Value");
 847   2          PCT_AudioRegList();
 848   2        } else if (commcode == PCT_StrToCommCode("again")) {
 849   2          // ===== Audio Gain Control =======
 850   2          //printf("Audio Gain Control");
 851   2          MoniAudioGain(strptr);
 852   2        } else if (commcode == PCT_StrToCommCode("alive")) {
 853   2          // ===== Audio Select Live & Mixing Mode =======
 854   2          //printf("Audio Select Live & Mixing Mode");
 855   2          MoniAudioLive(strptr);
 856   2        } else if (commcode == PCT_StrToCommCode("busrt")) {
 857   2          // ===== All Register Dump =======
 858   2          //printf("All Register Dump");
 859   2          MoniRegisterDump();
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 15  

 860   2        } else if (commcode == PCT_StrToCommCode("vmix")) {
 861   2          // ===== Video Mix's Windows Type Select =======
 862   2          //printf("Video Mix's Windows Type Select");
 863   2          PCT_WinAttrClear(WIN_FREEZE);
 864   2          MoniVideoMixWin(strptr);
 865   2          PCT_SendACK();
 866   2        } else if (commcode == PCT_StrToCommCode("vmixerr")) {
 867   2          // ===== Video Mix's Windows Type Select =======
 868   2          //printf("Video Mixerr's Windows Type Select");
 869   2          MoniVideoMixWin(strptr); 
 870   2        } else if (commcode == PCT_StrToCommCode("vattr")) {
 871   2          // ===== Video Mixing Control =======
 872   2          //printf("Video Attribute Control");
 873   2          MoniVideoMixAttr(strptr);
 874   2        } else if (commcode == PCT_StrToCommCode("yvmix")) {    // HiSharp has used
 875   2          // ===== Video Mixing Control =======
 876   2          PCT_SendACK();
 877   2          //printf("Video Attribute Control");
 878   2          MoniYVideoMix(strptr);
 879   2        } else if (commcode == PCT_StrToCommCode("init")) {
 880   2          // ===== TW2835 initial =======
 881   2          //printf("Initial TW2835");
 882   2          PCT_InitialTW2835();
 883   2        } else if (commcode == PCT_StrToCommCode("vdet")) {
 884   2          // ===== Video Mixing Control =======
 885   2          //printf("Auto Detectation Video Format");
 886   2          MoniVideoAutoDetect();
 887   2        } else if (commcode == PCT_StrToCommCode("vsetf")) {
 888   2          // ===== Video Mixing Control =======
 889   2          //printf("Setting Video Format Control");
 890   2          MoniSetVideoFormat(strptr);
 891   2        } else if (commcode == PCT_StrToCommCode("sstr")) {
 892   2          // ===== Show String on OSD =======
 893   2          //printf("Show String on OSD");
 894   2          MoniShowSODStr(strptr);
 895   2      // --------------------------------------------------------------------------------
 896   2        } else if (commcode == PCT_StrToCommCode("hscom")) {    // HiSharp has used
 897   2          PCT_SendACK();
 898   2          //printf("Command Shell for HiSharp");
 899   2          MoniHSComm(strptr);
 900   2      
 901   2          PCT_AudioActionForHS();
 902   2          PCT_OSDActionForHS();
 903   2          PCT_FlashOSDCtrl(OFF);
 904   2          
 905   2        //  VlossFlag = 0;  //ryan@20150318
 906   2        #ifdef AWT_NO_SIGNAL_MSG  //Pinchi 20150326 add
 907   2          DisUserTimer(USERTMID1);
 908   2          EnUserTimer(USERTMID0,5); 
 909   2      
 910   2        #endif
 911   2        } else if (commcode == PCT_StrToCommCode("mode")) {     // HiSharp has used
 912   2          PCT_SendACK();
 913   2          //printf("Command Shell for HiSharp Set S or J Mode");
 914   2          MoniHSCommSJmode(strptr);
 915   2        } else if (commcode == PCT_StrToCommCode("disscroll")) {  // HiSharp has used
 916   2          PCT_SendACK();
 917   2          //printf("Command Shell for HiSharp Disable Scroll!");
 918   2          MoniHSCommDisScroll();
 919   2        } else if (commcode == PCT_StrToCommCode("ver")) {  // HiSharp has used
 920   2          PCT_SendACK();
 921   2          //printf("Command Shell for HiSharp Disable Scroll!");
C51 COMPILER V9.60.0.0   COMMANDSHELL                                                      07/14/2021 15:23:06 PAGE 16  

 922   2          MoniHSCommVersion();
 923   2          #if (TW2837_DEBUG==ON)
 924   2          if(access==1)
 925   2            {
 926   3            access=0;
 927   3            Printf("\r\nACCESS=0");           
 928   3            }
 929   2          else
 930   2            {
 931   3            access=1;
 932   3            Printf("\r\nACCESS=1");           
 933   3            }
 934   2          #endif
 935   2          //PCT_InitialTW2835();//Kane @HS 2007 0723 Ver3.4
 936   2      // --------------------------------------------------------------------------------
 937   2        } else {
 938   2        }
 939   1      
 940   1        // ---------------------------------------------
 941   1        return true;
 942   1      }
 943          
 944          
 945          // ===========================================================================
 946          // END of File 
 947          // ===========================================================================
 948          
 949          
 950          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4365    ----
   CONSTANT SIZE    =    757    ----
   XDATA SIZE       =     26      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      72
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
