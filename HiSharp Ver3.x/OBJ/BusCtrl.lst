C51 COMPILER V9.50a   BUSCTRL                                                              03/28/2018 18:26:35 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE BUSCTRL
OBJECT MODULE PLACED IN .\OBJ\BusCtrl.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE BusCtrl.c COMPACT OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\OBJ\B
                    -usCtrl.lst) TABS(2) OBJECT(.\OBJ\BusCtrl.obj)

line level    source

   1          //  **************************************************************************
   2          //
   3          //       Copyright (c) 1992-2006 Professonal Computer Technology Co., Ltd
   4          //
   5          //      All rights are reserved. Reproduction in whole or in parts is
   6          //  prohibited without the prior written consent of the copyright owner.
   7          //  --------------------------------------------------------------------------
   8          //
   9          //  Module: BUSCTRL.C
  10          //
  11          //  Purpose: Implementation of BUSCTRL.
  12          //
  13          //  Version: 0.01                                   2006/10/22 10:39¤U¤È
  14          //
  15          //  Compiler: Keil 8051 C Compiler v7.2
  16          //
  17          //  Reference:
  18          //
  19          //
  20          //
  21          //  --------------------------------------------------------------------------
  22          //  Modification:
  23          //
  24          //  R0.01 2006/10/22 10:39¤U¤È Phoenix Chuang
  25          //  Reason:
  26          //    1. Original.
  27          //  Solution:
  28          //  
  29          //  **************************************************************************
  30          //  -----------------------------------
  31          //      Header Files
  32          //  ----------------------------------- 
  33          #include "Types.h"
  34          #include "BusCtrl.h"
  35          
  36          
  37          //  ------------------------------------
  38          //      Macro Definitions
  39          //  ------------------------------------ 
  40          
  41          
  42          //  ------------------------------------
  43          //      Type Definitions
  44          //  ------------------------------------
  45          
  46          
  47          //  ------------------------------------
  48          //      Variables Definitions
  49          //  ------------------------------------
  50          
  51          
  52          //  ------------------------------------
  53          //      Function Prototypes
  54          //  ------------------------------------
C51 COMPILER V9.50a   BUSCTRL                                                              03/28/2018 18:26:35 PAGE 2   

  55          
  56          
  57          // ===========================================================================
  58          //                      Parallel function description
  59          //==================================================================================
  60          //  
  61          //  
  62          //  
  63          void PCT_WriteAsicByte(U8 _dvc, U8 _pg, U8 _addr, U8 _wdat)
  64          {
  65   1        _dvc = 0;     //... temporal
  66   1      
  67   1        EA = OFF;   // Disable All Interrupt
  68   1        //... P[7:4]:INT[5:2], P1_3:HALE, P1_2:HRDB, P1_1:HWRB, P1_0:HSPB
  69   1        MCTRL = 0xf6;   //... initial state
  70   1      
  71   1        if(_pg == DVC_PG0){ HCSB1=0;  HCSB0=0;}
  72   1        else if(_pg == DVC_PG1){  HCSB1=0;  HCSB0=1;}
  73   1        else if(_pg == DVC_PG2){  HCSB1=1;  HCSB0=0;}
  74   1        MDATA = _addr;
  75   1        HALE = 1;
  76   1        HALE = 0;
  77   1        MDATA = _wdat;
  78   1        HWRB = 0;
  79   1        HWRB = 1;
  80   1      
  81   1        MCTRL = 0xf6;   //... initial state
  82   1        HCSB0=1;
  83   1        HCSB1=1;
  84   1        MDATA = 0xff;
  85   1        EA = ON;    // Enable All Interrupt
  86   1      }
  87          
  88          //==================================================================================
  89          //  
  90          //  
  91          //  
  92          void PCT_WriteAsicTable(U8 _dvc, U8 _pg, U8 _addr, U8 *_tbl_ptr, U8 _tbl_cnt)
  93          {
  94   1        _dvc = 0;     //... temporal
  95   1      
  96   1        EA = OFF;   // Disable All Interrupt
  97   1        //... P[7:4]:INT[5:2], P1_3:HALE, P1_2:HRDB, P1_1:HWRB, P1_0:HSPB
  98   1        MCTRL = 0xf6;   //... initial state
  99   1      
 100   1        if(_pg == DVC_PG0){ HCSB1=0;  HCSB0=0;}
 101   1        else if(_pg == DVC_PG1){  HCSB1=0;  HCSB0=1;}
 102   1        else if(_pg == DVC_PG2){  HCSB1=1;  HCSB0=0;}
 103   1      
 104   1        do {
 105   2          MDATA = _addr++;
 106   2          HALE = 1;
 107   2          HALE = 0;
 108   2        
 109   2          MDATA = *_tbl_ptr++;
 110   2          HWRB = 0;
 111   2          HWRB = 1;
 112   2        }while( --_tbl_cnt!=0 );
 113   1      
 114   1        MCTRL = 0xf6;   //... initial state
 115   1        HCSB0=1;
 116   1        HCSB1=1;
C51 COMPILER V9.50a   BUSCTRL                                                              03/28/2018 18:26:35 PAGE 3   

 117   1        MDATA = 0xff;
 118   1        EA = ON;    // Enable All Interrupt
 119   1      }
 120          
 121          //==================================================================================
 122          //  
 123          //  
 124          //  
 125          U8 PCT_ReadAsicByte(U8 _dvc, U8 _pg, U8 _addr)
 126          {
 127   1        register U8 _rdat_;
 128   1      
 129   1        EA = OFF;   // Disable All Interrupt
 130   1        //... P[7:4]:INT[5:2], P1_3:HALE, P1_2:HRDB, P1_1:HWRB, P1_0:HSPB
 131   1        MCTRL = 0xf6;   //... initial state
 132   1      
 133   1        _dvc = 0;     //... temporal
 134   1        if(_pg == DVC_PG0){ HCSB1=0; HCSB0=0;}
 135   1        else if(_pg == DVC_PG1){ HCSB1=0; HCSB0=1;}
 136   1        else if(_pg == DVC_PG2){ HCSB1=1; HCSB0=0;}
 137   1      
 138   1        MDATA = _addr;
 139   1        HALE = 1;
 140   1        HALE = 0;
 141   1        MDATA = 0xff;   // port0(MDATA) input mode
 142   1        HRDB = 0;
 143   1        _rdat_ = MDATA;
 144   1        HRDB = 1;
 145   1      
 146   1        MCTRL = 0xf6;   //... initial state
 147   1        HCSB0=1;
 148   1        HCSB1=1;
 149   1        EA = ON;    // Enable All Interrupt
 150   1        return _rdat_;
 151   1      }
 152          
 153          
 154          //==================================================================================
 155          //  
 156          //  Write Register Address & Data form Table until address=0xFFFF then STOP
 157          //  
 158          void PCT_WriteSTable(U8 _dvc, WRITE_REG_DATA *_tbl_ptr)
 159          {
 160   1        #define PAGE GETHBYTE(_tbl_ptr->addr)
 161   1        #define ADDR GETLBYTE(_tbl_ptr->addr)
 162   1      
 163   1        _dvc = 0;
 164   1        while( _tbl_ptr->addr!=0xFFFF ) {
 165   2            if(TW28_ReadByte(PAGE, ADDR) != _tbl_ptr->dat)//William @HS 2007 0829 Ver3.4
 166   2              {
 167   3          TW28_WriteByte(PAGE, ADDR, _tbl_ptr->dat);
 168   3              }
 169   2          _tbl_ptr++; 
 170   2        }
 171   1      }
 172          
 173          //==================================================================================
 174          //  
 175          // Change to I2C Control Mode
 176          //  
 177          void PTC_SwitchToI2CMode(void)
 178          {
C51 COMPILER V9.50a   BUSCTRL                                                              03/28/2018 18:26:35 PAGE 4   

 179   1      #ifdef TW28_I2CBUS
                HSPB  = 1;
                HALE  = 1;
                MDATA   = 0xFF; 
                HCSB0   = 0;
                HCSB1   = 0;
                HRDB  = 0;
                HWRB  = 0;
              #endif
 188   1      }
 189          
 190          // ===========================================================================
 191          // END of File 
 192          // ===========================================================================
 193          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    298    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----      14
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
